import { Callout } from 'nextra/components'


# Go quick start guide 

Learn how to create a Go application that connects to the Memgraph database, execute simple queries and runs a query module.
This will introduce you to the basics of Memgraph, Go driver and the Cypher query language. 

<Callout type="info"> 

Go driver

You can find the official Go driver on
[GitHub](https://github.com/neo4j/neo4j-go-driver).

</Callout>

## Prerequisites

To follow this guide, you will need:

- The newest version of **Go** [installed](https://golang.org/doc/install).
- A **running Memgraph instance**. If you need to set up Memgraph, take a look
  at the [Installation guide](/getting-started/install-memgraph).
- A basic understanding of graph databases and the property graph model.


## Project setup

Start by creating a new project directory and positioning yourself in it:

```bash
mkdir hello-memgraph
cd hello-memgraph
```

Next, initialize a new Go module:

```bash
go mod init hello-memgraph
```

You just used a go tool to create a new module file go.mod that takes care of your dependencies, if you are not familiar with it take a look at 
the guide on [how to write a Go code](https://go.dev/doc/code). 

Now you can create a new file `main.go` and add the following code snippet. 

```go
package main

import (
	"context"
	"fmt"

	"github.com/neo4j/neo4j-go-driver/v5/neo4j"
)

func main() {
    
	dbUri := "bolt://localhost:7687" // scheme://host(:port) (default port is 7687)
	driver, err := neo4j.NewDriverWithContext(dbUri, neo4j.BasicAuth("", "", ""))

	ctx := context.Background()
	defer driver.Close(ctx)

	err = driver.VerifyConnectivity(ctx)
	if err != nil {
		panic(err)
	} else {
		fmt.Println("Viola! Connected to Memgraph!")
	}

}

```

After that run the following command to install all the dependencies you have in your import section. 

```bash
go mod tidy
```

Now you can run the application with the following command:

```bash
go run ./main.go
```





We'll be using a simple Go application to demonstrate how to connect to a
running Memgraph instance.

Let's jump in and create our application.

**1.** Create a new directory for your app, for example `/MyApp` and position
yourself in it.<br /> **2.** Create a `program.go` file and add the following
code:

```go
package main

import (
    "fmt"
    "github.com/neo4j/neo4j-go-driver/v5/neo4j"
)

func main() {
    dbUri := "bolt://localhost:7687"
    driver, err := neo4j.NewDriver(dbUri, neo4j.BasicAuth("", "", ""))
    if err != nil {
        panic(err)
    }
    // Handle driver lifetime based on your application lifetime requirements  driver's lifetime is usually
    // bound by the application lifetime, which usually implies one driver instance per application
    defer driver.Close()
    item, err := insertItem(driver)
    if err != nil {
        panic(err)
    }
    fmt.Printf("%v\n", item.Message)
}

func insertItem(driver neo4j.Driver) (*Item, error) {
    // Sessions are short-lived, cheap to create and NOT thread safe. Typically create one or more sessions
    // per request in your web application. Make sure to call Close on the session when done.
    // For multi-database support, set sessionConfig.DatabaseName to requested database
    // Session config will default to write mode, if only reads are to be used configure session for
    // read mode.
    session := driver.NewSession(neo4j.SessionConfig{})
    defer session.Close()
    result, err := session.WriteTransaction(createItemFn)
    if err != nil {
        return nil, err
    }
    return result.(*Item), nil
}

func createItemFn(tx neo4j.Transaction) (interface{}, error) {
    records, err := tx.Run(
        "CREATE (a:Greeting) SET a.message = $message RETURN 'Node ' + id(a) + ': ' + a.message",
        map[string]interface{}{"message": "Hello, World!"})
    // In face of driver native errors, make sure to return them directly.
    // Depending on the error, the driver may try to execute the function again.
    if err != nil {
        return nil, err
    }
    record, err := records.Single()
    if err != nil {
        return nil, err
    }
    // You can also retrieve values by name, with e.g. `id, found := record.Get("n.id")`
    return &Item{
        Message: record.Values[0].(string),
    }, nil
}

type Item struct {
    Message string
}
```

**3.** Create a `go.mod` file by running:

```
go mod init example.com/hello
```

**4.** Add the **Bolt driver** with the command:

```
go get github.com/neo4j/neo4j-go-driver/v5
```

**5.** Run the app with the following command:

```
go run ./program.go
```

You should see an output similar to the following:

```
Node 0: Hello, World!
```

## Where to next?

For real-world examples of how to use Memgraph, we suggest you take a look at
the **[Tutorials](/)** page. You can also browse through
the **[How-to guides](/)** section to get an overview
of all the functionalities Memgraph offers.
