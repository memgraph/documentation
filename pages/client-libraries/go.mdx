import { Callout } from 'nextra/components'
import { Steps } from 'nextra/components'


# GO client guide 

## Quickstart 

Learn how to create a Go application that connects to the Memgraph database and executes simple queries. 
This will introduce the basics of Memgraph and the Go driver. 

For Go Memgraph currently depends on the [Neo4j Golang driver](https://pkg.go.dev/github.com/neo4j/neo4j-go-driver/v5/neo4j#pkg-types). 
Memgraph and Neo4j both support Bolt protocol and Cypher queries, which means that same driver can be used to connect to both databases. 
This is very convenient if there is a need to switch between the two databases.  This guide is based on the driver version v5 and above. Some examples may 
not be supported in older versions of the driver.

<Callout type="info"> 
Prerequisite, that won't be covered in the guide, but are necessary for following is installed [Go programming language](https://go.dev/dl/) and [Docker](https://docs.docker.com/get-docker/) in your local environment. 
</Callout>

<Steps>

### Run Memgraph 

Start by running Memgraph in the background. The easiest way to install and run Memgraph is by using Docker. Start the container with the following command:

```bash
docker run -p 7687:7687 -p 7444:7444 -p 3000:3000 --name memgraph memgraph/memgraph-platform
```

This will start [Memgraph platform](/getting-started/install-memgraph/docker), that includes,[Memgraph database](https://memgraph.com/memgraphdb), [Memgraph Lab](https://memgraph.com/lab) and [Memgraph MAGE](https://memgraph.com/docs/mage). Memgraph uses Bolt protocol to communicate with the client, for this reasone, port 7687 is exposed. 
Memgraph Lab is a web application you can use to visualize the data. It's accessible at [http://localhost:3000](http://localhost:3000) if Memgraph Platform is running correctly. The 7444 port enables Memgraph Lab to access and preview the logs, which is why both of these ports need to be exposed. 

For more information visit the getting started guide on [how to run Memgraph](/getting-started/install-memgraph/docker).

### Create a directory 

Next, create a directory for your project and positioning yourself in it:

```bash
mkdir hello-memgraph
cd hello-memgraph
```

### Initialize Go module 

In the next step, initialize a new Go module via the following command:

```bash
go mod init hello-memgraph
```

The command above uses a Go tool to create a new module file go.mod that takes care of dependenciesc in GO projects, if you are not familiar with it take a look at 
the basic guide on [how to write a Go code](https://go.dev/doc/code). 

### Write minimal working example 

Now you can create a new file `main.go` and add the following code snippet: 

```go
package main

import (
	"context"
	"fmt"

	"github.com/neo4j/neo4j-go-driver/v5/neo4j"
)

func main() {

	dbUser := ""
	dbPassword := ""
	dbUri := "bolt://localhost:7687" // scheme://host(:port) (default port is 7687)
	driver, err := neo4j.NewDriverWithContext(dbUri, neo4j.BasicAuth(dbUser, dbPassword, ""))
	ctx := context.Background()
	defer driver.Close(ctx)

	err = driver.VerifyConnectivity(ctx)
	if err != nil {
		panic(err)
	} else {
		fmt.Println("Viola! Connected to Memgraph!")
	}

	//Create indexes on developer and technology nodes
	indexes := []string{
		"CREATE INDEX ON :Developer(id);",
		"CREATE INDEX ON :Technology(id);",
		"CREATE INDEX ON :Developer(name);",
		"CREATE INDEX ON :Technology(name);",
	}

	//Create developer nodes
	developer_nodes := []string{
		"CREATE (n:Developer {id: 1, name:'Andy'});",
		"CREATE (n:Developer {id: 2, name:'John'});",
		"CREATE (n:Developer {id: 3, name:'Michael'});",
	}

	//Create technology nodes
	technology_nodes := []string{
		"CREATE (n:Technology {id: 1, name:'Memgraph', description: 'Fastest graph DB in the world!', createdAt: Date()})",
		"CREATE (n:Technology {id: 2, name:'Go', description: 'Go programming language ', createdAt: Date()})",
		"CREATE (n:Technology {id: 3, name:'Docker', description: 'Docker containerization engine', createdAt: Date()})",
		"CREATE (n:Technology {id: 4, name:'Kubernetes', description: 'Kubernetes container orchestration engine', createdAt: Date()})",
		"CREATE (n:Technology {id: 5, name:'Python', description: 'Python programming language', createdAt: Date()})",
	}

	//Create relationships between developers and technologies
	relationships := []string{
		"MATCH (a:Developer {id: 1}),(b:Technology {id: 1}) CREATE (a)-[r:LOVES]->(b);",
		"MATCH (a:Developer {id: 2}),(b:Technology {id: 3}) CREATE (a)-[r:LOVES]->(b);",
		"MATCH (a:Developer {id: 3}),(b:Technology {id: 1}) CREATE (a)-[r:LOVES]->(b);",
		"MATCH (a:Developer {id: 1}),(b:Technology {id: 5}) CREATE (a)-[r:LOVES]->(b);",
		"MATCH (a:Developer {id: 2}),(b:Technology {id: 2}) CREATE (a)-[r:LOVES]->(b);",
		"MATCH (a:Developer {id: 3}),(b:Technology {id: 4}) CREATE (a)-[r:LOVES]->(b);",
	}

	//Create a simple session
	session := driver.NewSession(ctx, neo4j.SessionConfig{DatabaseName: ""})
	defer session.Close(ctx)

	// Run index queries via implicit auto-commit transaction
	for _, index := range indexes {
		_, err = session.Run(ctx, index, nil)
		if err != nil {
			panic(err)
		}
	}
	fmt.Println("****** Indexes created *******")

	// Run developer node queries
	for _, node := range developer_nodes {
		_, err = neo4j.ExecuteQuery(ctx, driver, node, nil, neo4j.EagerResultTransformer, neo4j.ExecuteQueryWithDatabase(""))
		if err != nil {
			panic(err)
		}
	}
	fmt.Println("****** Developer nodes created *******")

	// Run technology node queries
	for _, node := range technology_nodes {
		_, err = neo4j.ExecuteQuery(ctx, driver, node, nil, neo4j.EagerResultTransformer, neo4j.ExecuteQueryWithDatabase(""))
		if err != nil {
			panic(err)
		}
	}
	fmt.Println("****** Technology nodes created *******")

	// Run relationship queries
	for _, rel := range relationships {
		_, err = neo4j.ExecuteQuery(ctx, driver, rel, nil, neo4j.EagerResultTransformer, neo4j.ExecuteQueryWithDatabase(""))
		if err != nil {
			panic(err)
		}
	}
	fmt.Println("****** Relationships created *******")

	// Read a node
	query := "MATCH (n:Technology{name: 'Memgraph'}) RETURN n;"
	result, err := neo4j.ExecuteQuery(ctx, driver, query, nil, neo4j.EagerResultTransformer, neo4j.ExecuteQueryWithDatabase(""))
	if err != nil {
		panic(err)
	}

	
	// Print the node results
	for _, node := range result.Records {
		fmt.Println(node.AsMap()["n"].(neo4j.Node))												// Node type
		fmt.Println(node.AsMap()["n"].(neo4j.Node).GetProperties())								// Node properties
		fmt.Println(node.AsMap()["n"].(neo4j.Node).GetElementId())								// Node internal ID
		fmt.Println(node.AsMap()["n"].(neo4j.Node).Labels)										// Node labels
		fmt.Println(node.AsMap()["n"].(neo4j.Node).Props["id"].(int64))							// Node user defined id property 
		fmt.Println(node.AsMap()["n"].(neo4j.Node).Props["name"].(string))						// Node user defined name property
		fmt.Println(node.AsMap()["n"].(neo4j.Node).Props["description"].(string))				// Node user defined description property
		fmt.Println(node.AsMap()["n"].(neo4j.Node).Props["createdAt"].(neo4j.Date).Time())		// Node user defined createdAt property

	}
	fmt.Println("****** End *******")
```

This is code snippet is a minimal working example that will create a connection to the Memgraph database via Go driver, create indexes,  create nodes and relationships, and read the data back. Take a look at the code in details, 
all the comments are there to help you understand what is happening. More details about code snippet will be explained in the [Go client API usage and examples](#go-client-api-usage-and-examples) section.

### Install dependencies

After that run the following command to install all the GO dependencies that are present in Go modules section. 

```bash
go mod tidy
```
At this point there should be only one dependecy, the Neo4j Go driver, and it should be installed. 

### Project hierarchy

The project hierarchy should look like this: 

```text
hello-memgraph
├── go.mod
├── main.go
├── go.sum

```
go.sum is a file that you should not touch, it is used by the Go tool to keep track of the dependencies checksums, and it is used to verify that the dependencies are not changed.

### Run the application

Now you can run the application with the following command:

```bash
go run ./main.go
```

If everything went well, in the terminal you should see the following output: 

```text
Viola! Connected to Memgraph!
****** Indexes created *******
****** Developer nodes created *******
****** Technology nodes created *******
****** Relationships created *******
****** Node values: *******
{52 52 [Technology] map[createdAt:{0 63828777600 <nil>} description:Fastest graph DB in the world! id:1 name:Memgraph]}
map[createdAt:{0 63828777600 <nil>} description:Fastest graph DB in the world! id:1 name:Memgraph]
52
[Technology]
1
Memgraph
Fastest graph DB in the world!
2023-08-28 00:00:00 +0000 UTC
****** End *******
```

### Visualize the data 

In order to visualize what has been created in the database with the main.go script, head over to http://localhost:3000/ and run `MATCH path=(n)-[p]-(m) RETURN path` at the Query Execution tab. 
That query will visualize the created nodes and relationships and by clicking on each node or relationship, you can explore different properties.

![go-quick-start](/pages/client-libraries/go/go-quick-start.png)

### Next steps 

This makes a good starting point for Go application.For more information on how to use the Go driver, 
continue reading the guide under [Go client API usage and examples](#go-client-api-usage-and-examples), by the section that interest you the most. 

</Steps>

## Go client API usage and examples 

### Database connection 

Once the database is running, and driver is installed or available in GO, you should be able to connect to the database. Connection to the database can be done in two ways:

- [Connect without authentication (default)](#connect-without-authentication-default)
- [Connect with authentication](#connect-with-authentication)

#### Connect without authentication (default)

By default, the Memgraph database is running without authentication, which means that you can connect to the database without providing any credentials. They include username and password.
To connect to Memgraph, create a driver object with the appropriate URI and credentials arguments. If you're running Memgraph locally, URI looks something like `bolt://localhost:7687`, and if you are running Memgraph on a remote server, 
replace `localhost` with the appropriate IP address. 
If you ran Memgraph on port different than 7687, do not forget to update that in the URI too. 

By default, you can set username and password in the `neo4j.BasicAuth("","","")` argument as empty strings. This means that you are connecting without authentication.

To connect a Go driver to the Memgraph database without authentication, you can use the following snippet: 

```go {12-13}
package main

import (
	"context"
	"fmt"

	"github.com/neo4j/neo4j-go-driver/v5/neo4j"
)

func main() {

    dbUri := "bolt://localhost:7687" // (Default Memgraph Bolt port is 7687)
	driver, err := neo4j.NewDriverWithContext(dbUri, neo4j.BasicAuth("", "", ""))

	ctx := context.Background()
	defer driver.Close(ctx)

	err = driver.VerifyConnectivity(ctx)
	if err != nil {
		panic(err)
	} else {
		fmt.Println("Viola! Connected to Memgraph!")
	}

}

``` 

Notice that BasicAuth takes three arguments, the first two are `username` and `password`, and the third one is the `realm`. 
For both `username` and `password`, the empty string is passed, which means that you are connecting without authentication.

#### Connect with authentication

In order to set up authentication in Memgraph, you need to set up a user, that has `username` and `password`. The simplest way to accomplish this is by running the query that sets a proper username and password, like this: 

```Cypher
CREATE USER `memgraph` IDENTIFIED BY 'memgraph';
```

You can run the following Query via Memgraph Lab

Then, you can connect to the database with the following snippet:

```go {12-15}
package main

import (
	"context"
	"fmt"

	"github.com/neo4j/neo4j-go-driver/v5/neo4j"
)

func main() {

	dbUser := "memgraph"
	dbPassword := "memgraph"
	dbUri := "bolt://localhost:7687" // (Default Memgraph Bolt port is 7687)
	driver, err := neo4j.NewDriverWithContext(dbUri, neo4j.BasicAuth(dbUser, dbPassword, ""))

	ctx := context.Background()
	defer driver.Close(ctx)

	err = driver.VerifyConnectivity(ctx)
	if err != nil {
		panic(err)
	} else {
		fmt.Println("Viola! Connected to Memgraph!")
	}

}

``` 

If you get and error like this: 

```panic: Neo4jError: Memgraph.ClientError.Security.Unauthenticated (Authentication failure)```
    
Then you have probably enabled authentication in Memgraph, but you are trying to connect without authentication. For more details on how to set authentication further, visit the [Memgraph authentication guide](/configuration/security/#creating-user).

#### Go client connection lifecycle management 

Once driver connection to Memgraph is established, there is no need for closing it. It is sufficient to open a single client connection to Memgraph and use it for all your queries.
In examples above the Go [context](https://pkg.go.dev/context) has been use to manage the lifecycle of the client. In this case The lifecycle of the client is tied to your application lifecycle.

So the following code snippet, will make sure to close the client connection once the application is finished: 

```go
ctx := context.Background()
defer driver.Close(ctx)
```

Keep in mind that driver object is thread safe, and can be reused between different threads. 

### Query the database 

After connecting your driver to the Memgraph you can start running some queries, the simplest way to run the query is via `ExecuteQuery` method that has an automatic transaction management. 

#### Run a create query 

Now here is the simple create query you can run to create a node inside the database: 

```go 
node := "CREATE (n:Technology {name:'Memgraph'});"
_, err = neo4j.ExecuteQuery(ctx, driver, node, nil, neo4j.EagerResultTransformer, neo4j.ExecuteQueryWithDatabase("memgraph"))
if err != nil {
	panic(err)
}
```

ExecuteQuery method takes the following arguments:

- `ctx` - context of the application
- `driver` - driver object that is connected to the Memgraph database
- `query` - Cypher query you want to execute
- `params` - parameters you want to pass to the query
- `resultTransformer` - result transformer that will transform the result into the desired format
- `config` - configuration of the query, like database name, user, etc.

Due to nature of `ExecuteQuery` method, transaction is handled automatically. 

#### Run a read query 

Here is the simple read query:

```go
result, err := neo4j.ExecuteQuery(ctx, driver, "MATCH (n:Technology{name: 'Memgraph'}) RETURN n", nil, neo4j.EagerResultTransformer, neo4j.ExecuteQueryWithDatabase("memgraph"))
if err != nil {
	panic(err)
} else {
	fmt.Println(result)
}

// Print each node as map
for _, node := range result.Records {
	fmt.Println(node.AsMap())
}
```
In this query each record contains a node, and you can access it by using `AsMap()` method.


#### Running queries with property map

If you want to pass a map of properties to the query, you can do it like this:

```go
_, err = neo4j.ExecuteQuery(ctx, driver, "CREATE (n:Technology{name: $name, type: $type})", map[string]any{"name": "Memgraph", "type": "graph database"}, neo4j.EagerResultTransformer, neo4j.ExecuteQueryWithDatabase(""))
if err != nil {
	panic(err)
}
```
This way your queries do not contain hard-coded values, and you can make your queries more dynamic.

### Process the results

In order to read results and serve them back to you Go application you need to handle them. Go is statically typed language and proper types need to be handled. 
Depending on the type of the request you made, you can get different results back. Lets go over a few basic examples on how to handle different types and access properties of the returned results.

#### Process the Node result

By running the following query:
```go
result, err := neo4j.ExecuteQuery(ctx, driver, "MATCH (n:Technology{name: 'Memgraph'}) RETURN n", nil, neo4j.EagerResultTransformer, neo4j.ExecuteQueryWithDatabase("memgraph"))
if err != nil {
    panic(err)
}
```
When using `ExceuteQuery`, the returned results are in the `EagerResults` format, which means you have access to the `Records` field. Records field contains all the records returned by the query. To process the results, you can iterate over the records and access the fields you need. 
Here is the example: 

```go
for _, node := range result.Records {
    fmt.Println(node.AsMap()["n"].(neo4j.Node))
}
```
```text
{65 65 [Technology] map[createdAt:{0 63828259200 <nil>} description:Fastest graph DB in the world! id:1 name:Memgraph]}
```

Lets break down the result. So for each returned record, it is getting converted to a map, now we can access the `n` field, which is a `Node` returned from a query. The returned record and all its properties are of type `any`. This means that you have to cast them to the relevant Go type if you want to use methods/features defined on such types. 
To access individual properties of the `Node` you have following options: 

```go
node.AsMap()["n"].(neo4j.Node).GetProperties() // map[createdAt:{0 63828259200 <nil>} description:Fastest graph DB in the world! id:1 name:Memgraph]
node.AsMap()["n"].(neo4j.Node).GetElementId() // 65
node.AsMap()["n"].(neo4j.Node).Labels // [Technology]
node.AsMap()["n"].(neo4j.Node).Props["id"].(int64) // 1
node.AsMap()["n"].(neo4j.Node).Props["name"].(string) // Memgraph
node.AsMap()["n"].(neo4j.Node).Props["description"].(string) // Fastest graph DB in the world!
node.AsMap()["n"].(neo4j.Node).Props["createdAt"].(neo4j.Date).Time() // 2023-08-22 00:00:00 +0000 UTC

```

As you can see you can access all `Node` properties by casting and accessing the `Props` field. Keep in mind that GetElementId() returns the internal ID of the node, which is not the same as the user defined ID, and it should not 
be used for any application level logic.


#### Process the Relationship result

You can also get a relationship back from the query. Here is the example: 

```go {14-22}
//Create a relationship between two nodes, developer and technology
query = "CREATE (d:Developer {name: 'John Doe'})-[:USES {id:99}]->(t:Technology {id: 1, name:'Memgraph', description: 'Fastest graph DB in the world!', createdAt: Date()});"
_, err = neo4j.ExecuteQuery(ctx, driver, query, nil, neo4j.EagerResultTransformer, neo4j.ExecuteQueryWithDatabase(""))
if err != nil {
	panic(err)
}

//Read a relationship between two nodes, developer and technology
query = "MATCH (d:Developer)-[r:USES]->(t:Technology) RETURN r"
result, err = neo4j.ExecuteQuery(ctx, driver, query, nil, neo4j.EagerResultTransformer, neo4j.ExecuteQueryWithDatabase(""))
if err != nil {
	panic(err)
}
// Process results 
for _, rel := range result.Records {
	fmt.Println(rel.AsMap()["r"].(neo4j.Relationship))
	fmt.Println(rel.AsMap()["r"].(neo4j.Relationship).GetProperties())
	fmt.Println(rel.AsMap()["r"].(neo4j.Relationship).GetElementId())
	fmt.Println(rel.AsMap()["r"].(neo4j.Relationship).Type)
	fmt.Println(rel.AsMap()["r"].(neo4j.Relationship).StartElementId)
	fmt.Println(rel.AsMap()["r"].(neo4j.Relationship).EndElementId)
	fmt.Println(rel.AsMap()["r"].(neo4j.Relationship).Props["id"].(int64))
}
```

You can access the `Relationship` properties in the same way as you access the node properties. StartElementId and EndElementId are the internal IDs of the start and end node of the relationship.

#### Process the Path result

You can also get a path back from the Memgraph, here is the example: 

```go
query = "MATCH p=(d:Developer)-[r:USES]->(t:Technology) RETURN p"
result, err = neo4j.ExecuteQuery(ctx, driver, query, nil, neo4j.EagerResultTransformer, neo4j.ExecuteQueryWithDatabase(""))
if err != nil {
	panic(err)
}

for _, path := range result.Records {
	fmt.Println(path.AsMap()["p"].(neo4j.Path))
	fmt.Println(path.AsMap()["p"].(neo4j.Path).Nodes)
	fmt.Println(path.AsMap()["p"].(neo4j.Path).Relationships)
}
```

Path will contain Nodes and Relationships, that can be accessed in the same way as in the previous examples, by casting them to the relevant type.


#### Types mapping and casting

 Here is the full table of the mapping between Memgraph Cypher types and the types used in the Go driver:

|  Cypher Type | Driver Type        |
|-------------:|:-------------------|
|          Null| nil                |
|       String | string             |
|      Boolean | bool               |
|      Integer | int64              |
|        Float | float              |
|         List | []any              |
|          Map | map[string]any     |
|         Node | neo4j.Node         |
| Relationship | neo4j.Relationship |
|         Path | neo4j.Path         |
|     Duration | neo4j.Duration     |
|         Date | neo4j.Date         |
|    LocalTime | neo4j.LocalTime    |
|LocalDateTime | neo4j.LocalDateTime|

Keep in mind that Memgraph does not support timezones at the moment. 

### Transaction management

#### Automatic transaction management 

By using simple `ExecuteQuery()` method, driver is taking care of the transaction for the Cypher query you are trying to execute. The `ExceuteQuery()` should be used in most case where you do not need transaction control, you can also pass multiple queries inside the `ExecuteQuery()`. 

<Callout type="warning">

Error with multicommand transactions

`Index manipulation not allowed in multicommand transactions` is a kind of error you might experience. To fix that, use [implicit (or auto-commit) transactions](#implicit-transactions) instead.
That is the simplest way to run a Cypher query because implicit transactions won't be automatically retried as with `execute_query()` procedure or managed transactions.
To create a label-property index on `:User(name)`, run the following code:

</Callout>

The automatic transaction managment has been used in the [Quickstart](#quickstart) section, so you can take a look at the code samples there, to see how it works.

#### Manual transaction management

##### Session management

Before doing any manual transaction management, you need to do is to create a session. Session is a specific connection to the database, that can live for certian time span. Session connection is lightweight and should be closed after the 
wanted queries has been executed. There is no need to keep the session open for the whole duration of the application. To open a session, use the code snippet below: 

```go
session := driver.NewSession(ctx, neo4j.SessionConfig{DatabaseName: "neo4j"})
defer session.Close(ctx)
```

Sessions are not thread safe, so you should create a new session for each Go routine. 

With sessions, you can run:

- [Manged transactions](#managed-transactions) - to run multiple queries with automatic retries without the possibility to roll back a query within a transaction.
- [Explicit transactions](#explicit-transactions) - to get full control over transactions by explicitly controlling the end of transaction that won't be automatically retried.
- [Implicit transactions](#implicit-transactions) - the simplest way to run a Cypher query that won't be automatically retried.


[Session](https://pkg.go.dev/github.com/neo4j/neo4j-go-driver/v5/neo4j#SessionWithContext) have multiple access points that can be used to access the database: 

- `ExecuteRead` - executes a defined transaction workload in read access mode with retry logic. (managed transaction)
- `ExecuteWrite` - executes a defined transaction workload in write access mode with retry logic. (managed transaction)
- `BeginTransaction` - starts a new explicit transaction. (explicit transaction)
- `Run` - executes a auto-commit statement and returns result. (implicit transaction)

##### Managed Transactions

In some cases when using automatic transactions via `ExecuteQuery`, you will lack an possibility to have business logic between transactions. For that reasone it is also possible to manually manage transactions, which can bring flexibility into how the queries are executed. 
Let's take a look into the basic example if you want to read data from the database, here is the example of the managed transaction:

```go {1-14}
	nodes, err := session.ExecuteRead(ctx,
		func(tx neo4j.ManagedTransaction) (any, error) {
			result, err := tx.Run(ctx, `  
				MATCH (n:Technology) WHERE n.name = "Memgraph"
				RETURN n;
				`, map[string]any{
				"filter": "Memgraph",
			})
			records, err := result.Collect(ctx)
			if err != nil {
				return nil, err
			}
			return records, nil
		})
	if err != nil {
		panic(err)
	} else {
		for _, tech := range nodes.([]*neo4j.Record) {
			fmt.Println(tech.AsMap())
		}
	}
```

Now the `session.ExecuteRead` gets the function as an argument, which is executed in the transaction, and the result is returned. 

But you could then do some custom processing on the result, run a second query inside the same transaction and return the result you want. 
The basic example would be this: 

```go {12-30}
nodes, err := session.ExecuteRead(ctx,
		func(tx neo4j.ManagedTransaction) (any, error) {
			result, err := tx.Run(ctx, `  
				MATCH (n:Technology) WHERE n.name = $filter
				RETURN n;
				`, map[string]any{
				"filter": "Memgraph",
			})
			if err != nil {
				return nil, err
			}
			records, _ := result.Collect(ctx)

			second_results, err := tx.Run(ctx, `
				MATCH (n:Technology) WHERE n.name = $filter
				RETURN n;
				`, map[string]any{
				"filter": "Go",
			})
			if err != nil {
				return nil, err
			}
			second_records, _ := second_results.Collect(ctx)

			records = append(records, second_records...)

			// Do some custom processing here

			return records, nil
		})
	if err != nil {
		panic(err)
	} else {
		for _, tech := range nodes.([]*neo4j.Record) {
			fmt.Println(tech.AsMap())
		}
	}
```

In the higlighted code you can see that we are running two queries inside the same transaction, and we are appending the results of the second query to the first one, you could chain this different queries as much as you want. This gives you felxibility to run different queries inside the same transaction, and do some custom processing on the results.

##### Explicit Transactions

Manged transaction cannot be `rolled back` or `commited` in some specific scenarios, for that Explicit transactions are used. Explicit transactions are the most flexible way to run a Cypher query. 
With explicit transactions, you have full control over the transaction, and you can explicitly control the end of the transaction.

Here is the basic example: 

```go
tx, err := session.BeginTransaction(ctx)
tx.Run(ctx, "CREATE (n:Technology {name:'Memgraph'});", nil)
tx.Commit(ctx) // or tx.Rollback(ctx)
```


Here is the full working example based on the explicit transaction: 

```go {52, 53}

func getTechNodesByName(ctx context.Context, tx neo4j.ExplicitTransaction, name string) (any, error) {
	result, err := tx.Run(ctx, `
		MATCH (n:Technology) WHERE n.name = $filter
		RETURN n;
		`, map[string]any{
		"filter": name,
	})
	if err != nil {
		return nil, err
	}
	records, _ := result.Collect(ctx)
	return records, nil
}

func getDevNodesByName(ctx context.Context, tx neo4j.ExplicitTransaction, name string) (any, error) {
	result, err := tx.Run(ctx, `
		MATCH (n:Developer) WHERE n.name = $filter
		RETURN n;
		`, map[string]any{
		"filter": name,
	})
	if err != nil {
		return nil, err
	}
	records, _ := result.Collect(ctx)
	return records, nil
}

	// Rest of the main missing for brevity

	tx, err := session.BeginTransaction(ctx)

	memgraph, err := getTechNodesByName(ctx, tx, "Memgraph")
	if err != nil {
		panic(err)
	}
	for _, node := range memgraph.([]*neo4j.Record) {
		fmt.Println(node.AsMap()["n"].(neo4j.Node))
	}

	goLang, err := getTechNodesByName(ctx, tx, "Go")
	if err != nil {
		panic(err)
	}
	for _, node := range goLang.([]*neo4j.Record) {
		fmt.Println(node.AsMap()["n"].(neo4j.Node))
	}

	//custom processing 

	err = tx.Commit(ctx) 
	// or tx.Rollback(ctx)
	if err != nil {

		fmt.Println("Error committing transaction")
		fmt.Println("Transaction rolled back because of error" + err.Error())
	}
	// Rest of the main missing for brevity

```


##### Implicit transaction 

Implicit or auto-commit transactions are the simplest way to run a Cypher query since they won't be automatically retried as with `executeQuery()` procedure or managed transactions.
With implicit transactions, you don't have the same control of transaction as with managed transactions. This is the most primitive way of runing transactions, here is the example: 


```go
	session := driver.NewSession(ctx, neo4j.SessionConfig{DatabaseName: "memgraph"})
	defer session.Close(ctx)

	session.Run(ctx, "CREATE INDEX ON :Developer(id);", nil)

```

The code above does not retry and does not have special checks, it just run the query and returns the result. if there is any. 

Since both automatic and explicit transaction are multi-statement transactions, creating an index, constraints, auth config queries are not possible in multi-line transactions. Hence, you need to use implicit transactions for those queries.


### Concurency
TBD

### Full code example
TBD

