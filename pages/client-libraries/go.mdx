import { Callout } from 'nextra/components'
import { Steps } from 'nextra/components'


# GO client guide 

## Quickstart 

Learn how to create a Go application that connects to the Memgraph database and executes simple queries. 
This will introduce you to the basics of Memgraph and the Go driver. This guide is based on the driver version v5 and above. Some examples may 
not be supported in older versions of the driver.

<Callout type="info"> 
Prerequisite for following this guides is installed [Go programming language](https://go.dev/dl/) and [docker](https://docs.docker.com/get-docker/) in your local environment. 
</Callout>

<Steps>
### Create a directory for your project 

Start by creating a new project directory and positioning yourself in it:

```bash
mkdir hello-memgraph
cd hello-memgraph
```

### Run Memgraph 

Now, you can start Memgraph in background. The easiest way is to use Docker image, start the container with the following command:

```bash
docker run -it -p 7687:7687 -p 7444:7444 -p 3000:3000 memgraph/memgraph-platform
```
This will start Memgraph platform, that includes, Memgraph database, Memgraph Lab and Memgraph MAGE. Memgraph uses Bolt protocol to communicate with the client, 
for that you need to expose the port 7687. Memgraph Lab is a web application that you can use to visualize your data, it is available on port 3000, and port 7444 is used for
logs that are visible in the Memgraph Lab. If the Memgraph Platform is running properly, open a URL http://localhost:3000 in your browser and you should see the Memgraph Lab UI.

### Initialize Go module 

In the next step, initialize a new Go module via the following command:

```bash
go mod init hello-memgraph
```

You just used a go tool to create a new module file go.mod that takes care of your dependencies, if you are not familiar with it take a look at 
the basic guide on [how to write a Go code](https://go.dev/doc/code). 

### Write minimal working example 

Now you can create a new file `main.go` and add the following code snippet:  

```go
package main

import (
	"context"
	"fmt"

	"github.com/neo4j/neo4j-go-driver/v5/neo4j"
)

package main

import (
	"context"
	"fmt"

	"github.com/neo4j/neo4j-go-driver/v5/neo4j"
)

func main() {

	dbUser := ""
	dbPassword := ""
	dbUri := "bolt://localhost:7687" // scheme://host(:port) (default port is 7687)
	driver, err := neo4j.NewDriverWithContext(dbUri, neo4j.BasicAuth(dbUser, dbPassword, ""))
	ctx := context.Background()
	defer driver.Close(ctx)

	err = driver.VerifyConnectivity(ctx)
	if err != nil {
		panic(err)
	} else {
		fmt.Println("Viola! Connected to Memgraph!")
	}

	//Create indexes on developer and technology nodes
	indexes := []string{
		"CREATE INDEX ON :Developer(id);",
		"CREATE INDEX ON :Technology(id);",
		"CREATE INDEX ON :Developer(name);",
		"CREATE INDEX ON :Technology(name);",
	}

	//Create developer nodes
	developer_nodes := []string{
		"CREATE (n:Developer {id: 1, name:'Andy'});",
		"CREATE (n:Developer {id: 2, name:'John'});",
		"CREATE (n:Developer {id: 3, name:'Michael'});",
	}

	//Create technology nodes
	technology_nodes := []string{
		"CREATE (n:Technology {id: 1, name:'Memgraph', description: 'Fastest graph DB in the world!', createdAt: Date()})",
		"CREATE (n:Technology {id: 2, name:'Go', description: 'Go programming language ', createdAt: Date()})",
		"CREATE (n:Technology {id: 3, name:'Docker', description: 'Docker containerization engine', createdAt: Date()})",
		"CREATE (n:Technology {id: 4, name:'Kubernetes', description: 'Kubernetes container orchestration engine', createdAt: Date()})",
		"CREATE (n:Technology {id: 5, name:'Python', description: 'Python programming language', createdAt: Date()})",
	}

	//Create relationships between developers and technologies
	relationships := []string{
		"MATCH (a:Developer {id: 1}),(b:Technology {id: 1}) CREATE (a)-[r:LOVES]->(b);",
		"MATCH (a:Developer {id: 2}),(b:Technology {id: 3}) CREATE (a)-[r:LOVES]->(b);",
		"MATCH (a:Developer {id: 3}),(b:Technology {id: 1}) CREATE (a)-[r:LOVES]->(b);",
		"MATCH (a:Developer {id: 1}),(b:Technology {id: 5}) CREATE (a)-[r:LOVES]->(b);",
		"MATCH (a:Developer {id: 2}),(b:Technology {id: 2}) CREATE (a)-[r:LOVES]->(b);",
		"MATCH (a:Developer {id: 3}),(b:Technology {id: 4}) CREATE (a)-[r:LOVES]->(b);",
	}

	//Create a simple session
	session := driver.NewSession(ctx, neo4j.SessionConfig{DatabaseName: ""})
	defer session.Close(ctx)

	// Run index queries via implicit auto-commit transaction
	for _, index := range indexes {
		_, err = session.Run(ctx, index, nil)
		if err != nil {
			panic(err)
		}
	}
	fmt.Println("****** Indexes created *******")

	// Run developer node queries
	for _, node := range developer_nodes {
		_, err = neo4j.ExecuteQuery(ctx, driver, node, nil, neo4j.EagerResultTransformer, neo4j.ExecuteQueryWithDatabase(""))
		if err != nil {
			panic(err)
		}
	}
	fmt.Println("****** Developer nodes created *******")

	// Run technology node queries
	for _, node := range technology_nodes {
		_, err = neo4j.ExecuteQuery(ctx, driver, node, nil, neo4j.EagerResultTransformer, neo4j.ExecuteQueryWithDatabase(""))
		if err != nil {
			panic(err)
		}
	}
	fmt.Println("****** Technology nodes created *******")

	// Run relationship queries
	for _, rel := range relationships {
		_, err = neo4j.ExecuteQuery(ctx, driver, rel, nil, neo4j.EagerResultTransformer, neo4j.ExecuteQueryWithDatabase(""))
		if err != nil {
			panic(err)
		}
	}
	fmt.Println("****** Relationships created *******")

	// Read a node
	query := "MATCH (n:Technology{name: 'Memgraph'}) RETURN n;"
	result, err := neo4j.ExecuteQuery(ctx, driver, query, nil, neo4j.EagerResultTransformer, neo4j.ExecuteQueryWithDatabase(""))
	if err != nil {
		panic(err)
	}

	
	// Print the node results
	for _, node := range result.Records {
		fmt.Println(node.AsMap()["n"].(neo4j.Node))												// Node type
		fmt.Println(node.AsMap()["n"].(neo4j.Node).GetProperties())								// Node properties
		fmt.Println(node.AsMap()["n"].(neo4j.Node).GetElementId())								// Node internal ID
		fmt.Println(node.AsMap()["n"].(neo4j.Node).Labels)										// Node labels
		fmt.Println(node.AsMap()["n"].(neo4j.Node).Props["id"].(int64))							// Node user defined id property 
		fmt.Println(node.AsMap()["n"].(neo4j.Node).Props["name"].(string))						// Node user defined name property
		fmt.Println(node.AsMap()["n"].(neo4j.Node).Props["description"].(string))				// Node user defined description property
		fmt.Println(node.AsMap()["n"].(neo4j.Node).Props["createdAt"].(neo4j.Date).Time())		// Node user defined createdAt property

	}
	fmt.Println("****** End *******")

```

This is code snippet is a minimal working example that will create a connection to the Memgraph database via Go driver, create indexes,  create nodes and relationships, and read the data back. Take a look at the code in details, 
all the comments are there to help you understand what is happening. More details about code snippet will be explained in the [Go client API usage and examples](#go-client-api-usage-and-examples) section.

### Install dependencies
After that run the following command to install all the GO dependencies you have in your import section. 

```bash
go mod tidy
```
At this point you should have only one dependency, the Neo4j Go driver, and it should be installed. 

### Run the application
Now you can run the application with the following command:

```bash
go run ./main.go
```

If everything went well, you should see the following output: 

```text
Viola! Connected to Memgraph!
****** Indexes created *******
****** Developer nodes created *******
****** Technology nodes created *******
****** Relationships created *******
****** Node values: *******
{52 52 [Technology] map[createdAt:{0 63828777600 <nil>} description:Fastest graph DB in the world! id:1 name:Memgraph]}
map[createdAt:{0 63828777600 <nil>} description:Fastest graph DB in the world! id:1 name:Memgraph]
52
[Technology]
1
Memgraph
Fastest graph DB in the world!
2023-08-28 00:00:00 +0000 UTC
****** End *******
```


### Visualize the data 
If you want to visualize what you created in the database with the main.go script, head over to localhost:3000 and run `MATCH path=(n)-[p]-(m) RETURN path` at the Query Execution tab. 
That query will visualize the created nodes and relationships and by clicking on it you can explore node and relationship properties.

![go-quick-start](/pages/client-libraries/go/go-quick-start.png)

### Next steps 

This makes a good starting point for your Go application. You can now start building your application on top of this example. For more information on how to use the Go driver, 
continue reading the guide under [Go client API usage and examples](#go-client-api-usage-and-examples), by the section that interest you the most. 

</Steps>

## Go client API usage and examples 

### Database connection 

Once the database is running, and you have driver installed you will be able to Memgraph. For Golang Memgraph currently depends on the (Neo4j Golang driver)[https://pkg.go.dev/github.com/neo4j/neo4j-go-driver/v5/neo4j#pkg-types]. Memgraph and Neo4j both support Bolt protocol and Cypher queries, 
which means that you can use the same driver to connect to both databases. This is very convenient if you want to switch between the two databases. 

#### Connect without authentication (default)

By default, the Memgraph database is running without authentication, which means that you can connect to the database without providing any credentials. 
To connect to Memgraph, create a driver object with the appropriate URI and AUTH arguments. If you're running Memgraph locally, URI looks something like `bolt://localhost:7687`, and if you are running Memgraph on a remote server, 
replace `localhost` with the appropriate IP address. 
If you ran Memgraph on port different than 7687, don't forget to update that in the URI too. 
By default, you can set username and password in the AUTH argument as empty strings. But, if you [created a user](/configuration/security/#creating-user) in Memgraph, make sure to provide the correct connection details.

To connect a Go driver to the Memgraph database, you can use the following snippet: 

```go
package main

import (
	"context"
	"fmt"

	"github.com/neo4j/neo4j-go-driver/v5/neo4j"
)

func main() {

    dbUri := "bolt://localhost:7687" // (Default Memgraph Bolt port is 7687)
	driver, err := neo4j.NewDriverWithContext(dbUri, neo4j.BasicAuth("", "", ""))

	ctx := context.Background()
	defer driver.Close(ctx)

	err = driver.VerifyConnectivity(ctx)
	if err != nil {
		panic(err)
	} else {
		fmt.Println("Viola! Connected to Memgraph!")
	}

}

``` 

Notice that BasicAuth takes three arguments, the first two are username and password, and the third one is the realm. 
For both username and password, you can pass an empty string, this means that you are connecting without authentication.

#### Connect with authentication

If you have enabled authentication in Memgraph by setting a proper username and password, like this: 

```Cypher
CREATE USER `memgraph` IDENTIFIED BY 'memgraph';
```

Then, you can connect to the database with the following snippet:

```go
package main

import (
	"context"
	"fmt"

	"github.com/neo4j/neo4j-go-driver/v5/neo4j"
)

func main() {
	dbUser := "memgraph"
	dbPassword := "memgraph"
	dbUri := "bolt://localhost:7687" // (Default Memgraph Bolt port is 7687)
	driver, err := neo4j.NewDriverWithContext(dbUri, neo4j.BasicAuth(dbUser, dbPassword, ""))

	ctx := context.Background()
	defer driver.Close(ctx)

	err = driver.VerifyConnectivity(ctx)
	if err != nil {
		panic(err)
	} else {
		fmt.Println("Viola! Connected to Memgraph!")
	}

}

``` 

If you get and error like this: 

```panic: Neo4jError: Memgraph.ClientError.Security.Unauthenticated (Authentication failure)```
    
Then you have probably enabled authentication in Memgraph, but you are trying to connect without authentication.

#### Go client connection lifecycle management 

It is sufficient to open a single client connection to Memgraph and use it for all your queries. Once client connection is open, we can use 
Go (context)[https://pkg.go.dev/context] to manage the lifecycle of the client. The lifecycle of the client is tied to your application lifecycle.

So the following code snippet, will make sure to close the client connection once the application is finished: 

```go
ctx := context.Background()
defer driver.Close(ctx)
```

### Query the database 

After connection your driver to the Memgraph you can start running some queries, the simplest way to run the query is via `ExecuteQuery` function that has an automatic transaction management. 

#### Run a create query 

Now here is the simple create query you can run: 

```go 
    node := "CREATE (n:Technology {name:'Memgraph'});"
    _, err = neo4j.ExecuteQuery(ctx, driver, node, nil, neo4j.EagerResultTransformer, neo4j.ExecuteQueryWithDatabase("memgraph"))
    if err != nil {
        panic(err)
    }
```

ExecuteQuery function takes the following arguments:

- `ctx` - context of the application
- `driver` - driver object that is connected to the Memgraph database
- `query` - Cypher query you want to execute
- `params` - parameters you want to pass to the query
- `resultTransformer` - result transformer that will transform the result into the desired format
- `config` - configuration of the query, like database name, user, etc.


#### Run a read query 

Here is the simple read query:

```go
	result, err := neo4j.ExecuteQuery(ctx, driver, "MATCH (n:Technology{name: 'Memgraph'}) RETURN n", nil, neo4j.EagerResultTransformer, neo4j.ExecuteQueryWithDatabase("memgraph"))
	if err != nil {
		panic(err)
	} else {
		fmt.Println(result)
	}

	// Print each node as map
	for _, node := range result.Records {
		fmt.Println(node.AsMap())
	}
```

#### Running queries with property map

If you want to pass a map of properties to the query, you can do it like this:

```go
	_, err = neo4j.ExecuteQuery(ctx, driver, "CREATE (n:Technology{name: $name, type: $type})", map[string]any{"name": "Memgraph", "type": "graph database"}, neo4j.EagerResultTransformer, neo4j.ExecuteQueryWithDatabase(""))
	if err != nil {
		panic(err)
    }
```
This way your queries won't contain hard-coded values. 

### Process the returned results from 

In order to read results and serve them back to you Go application you need to handle them. Go is statically typed language and proper types need to be handled. 
Depending on the type of the request you made, you can get different results back. Lets go over a few examples how you can interpret the results. 

#### Get node 

Run the following query:
```go

result, err := neo4j.ExecuteQuery(ctx, driver, "MATCH (n:Technology{name: 'Memgraph'}) RETURN n", nil, neo4j.EagerResultTransformer, neo4j.ExecuteQueryWithDatabase("memgraph"))
if err != nil {
    panic(err)
}
```
When using `ExceuteQuery`, the returned results are in the `EagerResults` format, which means you have access to the `Records` field. Records field contains all the records returned by the query. To process the results, you can iterate over the records and access the fields you need. 
Here is the example: 

```go
for _, node := range result.Records {
    fmt.Println(node.AsMap()["n"].(neo4j.Node))
}
```
```text
{65 65 [Technology] map[createdAt:{0 63828259200 <nil>} description:Fastest graph DB in the world! id:1 name:Memgraph]}
```

Lets break down the result. So for each returned record, it is getting converted to a map, now we can access the `n` field, which is a node returned from a query. The returned record and all its properties are of type `any`. This means that you have to cast them to the relevant Go type if you want to use methods/features defined on such types. 
To access individual properties of the node you have following options: 

```go
node.AsMap()["n"].(neo4j.Node).GetProperties() // map[createdAt:{0 63828259200 <nil>} description:Fastest graph DB in the world! id:1 name:Memgraph]
node.AsMap()["n"].(neo4j.Node).GetElementId() // 65
node.AsMap()["n"].(neo4j.Node).Labels // [Technology]
node.AsMap()["n"].(neo4j.Node).Props["id"].(int64) // 1
node.AsMap()["n"].(neo4j.Node).Props["name"].(string) // Memgraph
node.AsMap()["n"].(neo4j.Node).Props["description"].(string) // Fastest graph DB in the world!
node.AsMap()["n"].(neo4j.Node).Props["createdAt"].(neo4j.Date).Time() // 2023-08-22 00:00:00 +0000 UTC

```

As you can see you can access all node properties by casting and accessing the `Props` field. Keep in mind that GetElementId() returns the internal ID of the node, which is not the same as the user defined ID, and it should not 
be used for any business logic.


#### Get relationship

You can also get a relationship back from the query. Here is the example: 

```go 
	//Create a relationship between two nodes, developer and technology
	query = "CREATE (d:Developer {name: 'John Doe'})-[:USES {id:99}]->(t:Technology {id: 1, name:'Memgraph', description: 'Fastest graph DB in the world!', createdAt: Date()});"
	_, err = neo4j.ExecuteQuery(ctx, driver, query, nil, neo4j.EagerResultTransformer, neo4j.ExecuteQueryWithDatabase(""))
	if err != nil {
		panic(err)
	}

	//Read a relationship between two nodes, developer and technology
	query = "MATCH (d:Developer)-[r:USES]->(t:Technology) RETURN r"
	result, err = neo4j.ExecuteQuery(ctx, driver, query, nil, neo4j.EagerResultTransformer, neo4j.ExecuteQueryWithDatabase(""))
	if err != nil {
		panic(err)
	}
	for _, rel := range result.Records {
		fmt.Println(rel.AsMap()["r"].(neo4j.Relationship))
		fmt.Println(rel.AsMap()["r"].(neo4j.Relationship).GetProperties())
		fmt.Println(rel.AsMap()["r"].(neo4j.Relationship).GetElementId())
		fmt.Println(rel.AsMap()["r"].(neo4j.Relationship).Type)
		fmt.Println(rel.AsMap()["r"].(neo4j.Relationship).StartElementId)
		fmt.Println(rel.AsMap()["r"].(neo4j.Relationship).EndElementId)
		fmt.Println(rel.AsMap()["r"].(neo4j.Relationship).Props["id"].(int64))
	}
```

You can access the relationship properties in the same way as you access the node properties. StartElementId and EndElementId are the internal IDs of the start and end node of the relationship.

#### Get a path  

You can also get a path back from the Memgraph, here is the example: 

```go
	query = "MATCH p=(d:Developer)-[r:USES]->(t:Technology) RETURN p"
	result, err = neo4j.ExecuteQuery(ctx, driver, query, nil, neo4j.EagerResultTransformer, neo4j.ExecuteQueryWithDatabase(""))
	if err != nil {
		panic(err)
	}

	for _, path := range result.Records {
		fmt.Println(path.AsMap()["p"].(neo4j.Path))
		fmt.Println(path.AsMap()["p"].(neo4j.Path).Nodes)
		fmt.Println(path.AsMap()["p"].(neo4j.Path).Relationships)
	}
```

Path will contain nodes and relationships, that can be accessed in the same way as in the previous examples.


#### Types mapping Cypher and Go 

 Here is the full table of the mapping between Memgraph Cypher types and the types used in the Go driver:

|  Cypher Type | Driver Type        |
|-------------:|:-------------------|
|          Null| nil                |
|       String | string             |
|      Boolean | bool               |
|      Integer | int64              |
|        Float | float              |
|         List | []any              |
|          Map | map[string]any     |
|         Node | neo4j.Node         |
| Relationship | neo4j.Relationship |
|         Path | neo4j.Path         |
|     Duration | neo4j.Duration     |
|         Date | neo4j.Date         |
|    LocalTime | neo4j.LocalTime    |
|LocalDateTime | neo4j.LocalDateTime|

Keep in mind that Memgraph does not support timezones at the moment. 

### Transaction management

#### Automatic transaction management 

By using simple ExecuteQuery method, driver is taking care of the transaction for the Cypher query you are trying to execute. It is also possible
to manually manage transactions, which can bring flexibility into how the queries are executed. For example, you can batch multiple cypher queries into 
the single transaction, which in the case of write queries can bring significant performance improvements.


## Session and transaction 

The first thing you need to do is to create a session. Session is a specific connection to the database, that is lightweight and should be closed after the 
wanted queries has been executed. There is no need to keep the session open for the whole duration of the application. To open a session, use the code snippet below: 

```go
session := driver.NewSession(ctx, neo4j.SessionConfig{DatabaseName: "neo4j"})
defer session.Close(ctx)
```

Sessions are not thread safe, so you should create a new session for each goroutine.

[Session](https://pkg.go.dev/github.com/neo4j/neo4j-go-driver/v5/neo4j#SessionWithContext) have multiple access points that can be used to access the database: 

- `ExecuteRead` - executes a defined transaction workload in read access mode with retry logic. 
- `ExecuteWrite` - executes a defined transaction workload in write access mode with retry logic.
- `Run` - executes a auto-commit statement and returns result.


Let's take a look into the basic example if you want to read data from the database.
Now you can run manged transaction like this: 

```go 
	nodes, err := session.ExecuteRead(ctx,
		func(tx neo4j.ManagedTransaction) (any, error) {
			result, err := tx.Run(ctx, `  
				MATCH (n:Technology) WHERE n.name = "Memgraph"
				RETURN n;
				`, map[string]any{
				"filter": "Memgraph",
			})
			if err != nil {
				return nil, err
			}
			records, err := result.Collect(ctx)
			if err != nil {
				return nil, err
			}
			return records, nil
		})
	if err != nil {
		panic(err)
	} else {
		for _, tech := range nodes.([]*neo4j.Record) {
			fmt.Println(tech.AsMap())
		}
	}
```

Now the `session.ExecuteRead` gets the function as an argument, which is executed in the transaction. The function gets the transaction context as an argument, 
that is possible to use in the context. 





