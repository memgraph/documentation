---
title: JavaScript quick start
description: Understand the dynamics of Memgraph in association with JavaScript. Our documentation spells out the steps for an effective JavaScript integration
---

import { Callout } from 'nextra/components'
import { Steps } from "nextra/components";

# JavaScript client library guide

<Callout type="info">

Running queries directly from a web browser is **not 
recommended** because of additional requirements and possible 
performance issues. In other words, we encourage you to use 
server-side libraries and clients for top performance whenever 
possible.

</Callout>

## Quickstart

With this JavaScript quickstart guide learn the first steps 
of connecting to Memgraph and executing simple queries.

These instructions will guide you through your first steps of 
connecting to a running Memgraph database instance and visualizing 
your data using JavaScript.

<Steps>

### Install JavaScript Driver

To create the following JavaScript application, you first need
to install the JavaScript Driver.

Run the following *npm* command to install the [Neo4j JavaScript 
Driver](https://www.npmjs.com/package/neo4j-driver):

```
npm i neo4j-driver
```

<Callout type="info">

The Driver requires `npm` and any LTS version of node.js.

</Callout>

### Run Memgraph
The easiest way to start Memgraph is by running Memgraph 
Platform Docker image with the following command:

```
docker run -p 7687:7687 -p 7444:7444 -p 3000:3000 memgraph/memgraph-platform
```

Communication with the database can be established via Bolt 
protocol using Cypher queries through the exposed port 7687. 
Once the `docker run` command is executed, you will have a running 
Memgraph instance on `localhost:7687`.
Execute Cypher queries using Memgraph Lab on 
`localhost:3000`, a locally installed desktop version of [Memgraph 
Lab](/data-visualization/install-and-connect) or a client library.

### Set up your script

Create a new directory for your application and position
yourself in it:

```
mkdir myApp
cd myApp
```

Next, create an `example.js` file
and add the following code:

```js
(async () => {
    var db = require('neo4j-driver');
  
    const URI = 'bolt://localhost:7687';
    const USER = '';
    const PASSWORD = '';
    let driver;
  
    try {
      driver = db.driver(URI, db.auth.basic(USER, PASSWORD));
      const serverInfo = await driver.getServerInfo();
      console.log('Connection established');
      console.log(serverInfo);

      const session = driver.session();

      try {
        // Clear the database
        await session.run("MATCH (n) DETACH DELETE n;");
        console.log("Database cleared.");

        // Create a user in the database
        await session.run("CREATE (:Person {name: 'Alice', age: 22});");
        console.log("Record created.");

        // Get all of the nodes
        const result = await session.run("MATCH (n) RETURN n;");
        console.log("Record matched.");

        const mark = result.records[0].get("n");
        const label = mark.labels[0];
        const name = mark.properties["name"];
        const age = mark.properties["age"];

        if (label != "Person" || name != "Alice" || age != 22) {
          console.error("Data doesn't match.");
        }

        console.log("Label: " + label);
        console.log("Name: " + name);
        console.log("Age: " + age);
      } catch (error) {
        console.error(error);
      } finally {
        session.close();
      }

      driver.close();

    } catch (err) {
      console.log(`Connection error\n${err}\nCause: ${err.cause}`);
      await driver.close();
      return;
    }
  
    await driver.close();
  })();
```

### Run the script

After running your script with node `example.js`,
you should receive the output in your terminal similar to this: 

```
Database cleared.
Record created.
Record matched.
Label: Person
Name: Alice
Age: 22
```
The output above indicates that you are connected to the database and ready to visualize data
you created.

### Visualize the data

To visualize data created with the script, head over to 
`localhost:3000` or the desktop version of Memgraph Lab and run the following query in the *Query Execution* tab: 

```MATCH (n) RETURN n;``` 

The query visualizes the created node and by clicking on it you can 
explore its properties.

![javascript-quick-start](/pages/client-libraries/javascript/javascript-quick-start.png) 

### Next steps

You now have the basic JavaScript application that connects
you to Memgraph and you are ready to start building more 
complex queries on top of it. Happy querying!

</Steps>

## JavaScript library usage

Once we covered the basic concept, we can explore more advanced usages 
of JavaScript library, such as having different ways of authentication 
when connecting to database and efficiently managing your transactions.

### Database connection

To connect to Memgraph, create a driver object with the appropriate 
*URI* and *AUTH* arguments. If you're running Memgraph locally, 
*URI* should be similar to `bolt://localhost:7687`, and if you 
are running Memgraph on a remote server, replace `localhost` with 
the appropriate IP address. 

By default, you can set the `USER` and `PASSWORD` as empty strings. 
But, if you [created a user](/configuration/security#creating-users) 
in Memgraph, make sure to provide the **correct connection details**.
 
#### Connect without authentication

By default, the Memgraph database is running without authentication, 
which means that you can connect to the database without providing any 
credentials. Here is an example of how to connect to Memgraph, that is 
running locally on port 7687, with the JavaScript client library 
**without authentication** and get the node count from the database:

```js
(async () => {
    var db = require('neo4j-driver');
  
    const URI = 'bolt://localhost:7687';
    const USER = '';
    const PASSWORD = '';
    let driver;
  
    try {
      driver = db.driver(URI, db.auth.basic(USER, PASSWORD));
      const serverInfo = await driver.getServerInfo();
      console.log('Connection established');
      console.log(serverInfo);

      const session = driver.session();

      // Count the nodes in the database
      await session.run("MATCH (n) RETURN count(n) AS num_of_nodes;");
      console.log("Database cleared.");

      driver.close();

    } catch (err) {
      console.log(`Connection error\n${err}\nCause: ${err.cause}`);
      await driver.close();
      return;
    }
  
    await driver.close();
  })();
```

#### Connect with authentication

If you created a user in Memgraph and enabled authentication by creating 
a user and password like in the query below, you need to provide the correct 
username and password when defining authentication arguments to connect to 
the database. 

```CREATE USER `memgraph` IDENTIFIED BY 'password';```

Here is an example 
of how to connect to Memgraph that is running locally on port 7687, 
with the JavaScript client library **with authentication** and get the node 
count from the database:

```js
(async () => {
    var db = require('neo4j-driver');
  
    const URI = 'bolt://localhost:7687';
    const USER = 'memgraph';
    const PASSWORD = 'password';
    let driver;
  
    try {
      driver = db.driver(URI, db.auth.basic(USER, PASSWORD));
      const serverInfo = await driver.getServerInfo();
      console.log('Connection established');
      console.log(serverInfo);

      const session = driver.session();

      // Clear the database
      await session.run("MATCH (n) RETURN count(n) AS num_of_nodes;");
      console.log("Database cleared.");

      driver.close();

    } catch (err) {
      console.log(`Connection error\n${err}\nCause: ${err.cause}`);
      await driver.close();
      return;
    }
  
    await driver.close();
  })();
```


### Transactions management

When querying the database, the driver automatically creates a transaction. 
A transaction is a unit of work that is either *committed* in its entirety 
or *rolled back* on failure. For more advanced use-cases, the driver provides 
functions to take full control over the **transaction lifecycle**.

#### Manual transactions

Before running a transaction, you need to obtain a *session*. Sessions act 
as concrete query channels between the driver and the server, and ensure 
causal consistency is enforced. 

`session = driver.session()`

<Callout type="info">

Sessions are not thread-safe, which means you can share the main Driver object across 
threads, but make sure each thread creates its own sessions.

</Callout>

##### Managed transactions

A transaction can contain any number of queries. As Memgraph is 
**ACID compliant**, queries within a transaction will either be 
executed as a whole or not at all. 
You cannot get a part of the transaction succeeding and another 
failing. Use transactions to group together related queries which 
work together to achieve a single logical database operation.

A **managed transaction** is created using the `session.executeRead()` 
and `session.executeWrite()` methods, depending on whether you 
want to retrieve data from the database or alter it. Both methods 
take a transaction function callback, which is responsible for 
carrying out the queries and processing the results. Here's an 
example of a managed transaction using the `session.executeRead()` 
method.

```js
try {
  let session, result
  // Create a session
  session = driver.session()

  // The `.executeRead()` method is the entry point into a transaction  
  result = await session.executeRead(async tx => { 
    // Use the method `Transaction.run()` to run queries
    return await tx.run(`  
      MATCH (p:Person) WHERE p.name = 'Alice'
      RETURN p.name as name ORDER BY name
      `, {filter: 'Al'}
    )
  })
  // Process the result records
  for(let record of result.records) {  
    console.log(record.get('name'))
  }
} finally {
  // Remember to close session when done
  session.close()
}

```

Within a transaction function, a return statement results in the transaction 
being committed, while the transaction is **automatically rolled back** if 
an exception is raised.

Because of this, it is impossible to know how many time the transaction is going to be executed, so transaction functions should produce the same results even when run several times. This means you shouldn't, for example, 
 edit nor
rely on globals. Note that although transaction functions might be 
executed multiple times, the queries inside it will always run only once.

##### Explicit transactions

You can achieve full control over transactions by manually starting them using the 
`session.beginTransaction()` method. You run queries inside an explicit transaction 
with the `Transaction.run()` method, as you do in transaction functions.

```js
let session = driver.session({ database: 'neo4j' })
let transaction = await session.beginTransaction()

// await transaction.run('<QUERY 1>')
// await transaction.run('<QUERY 2>')
// ...

await transaction.close()
await session.close()
```

The behavior and lifetime of an explicit transaction is controlled using the `Transaction.commit()`, `Transaction.rollback()`, or `Transaction.close()` methods .

Explicit transactions are useful when applications need to distribute 
Cypher execution across multiple functions for the same transaction or 
run multiple queries within a single transaction but 
without the automatic retries provided by managed transactions.
