import { Callout } from 'nextra/components'
import { Steps } from "nextra/components";

# JavaScript client library guide

## Quickstart

With this JavaScript quickstart guide learn the first steps 
of connecting to Memgraph and executing simple queries.

<Callout type="info">

Running queries directly from a web browser is **not 
recommended** because of additional requirements and possible 
performance issues. In other words, we encourage you to use 
server-side libraries and clients for top performance whenever 
possible.

</Callout>

These instructions will guide you through your first steps of 
connecting to a running Memgraph database instance and visualizing 
your data using JavaScript:

<Steps>

### Install JavaScript Driver

To create the following JavaScript application, you first need
to install the JavaScript Driver and have a 
[**running Memgraph instance**](/client-libraries/javascript#run-memgraph).
Run the following *npm* command to install the [Neo4j JavaScript 
Driver](https://www.npmjs.com/package/neo4j-driver):

```
npm i neo4j-driver
```

<Callout type="info">

The Driver requires npm and any LTS version of node.js

</Callout>

### Run Memgraph
The easiest way to start Memgraph is by running Memgraph 
Platform Docker image with the following command:

```
docker run -it -p 7687:7687 -p 7444:7444 -p 3000:3000 memgraph/memgraph-platform
```

Memgraph uses Bolt protocol to communicate with the client 
using the exposed port 7687. Once the command is executed, 
you will have a running Memgraph instance on `localhost:7687`.
To communicate with the database, use Memgraph Lab on 
`localhost:3000`, a locally installed desktop version of [Memgraph 
Lab](/data-visualization/install-and-connect) or a client library.

### Set up your script

Create a new directory for your application and position
yourself in the terminal in it by running:

```
mkdir myApp
cd myApp
```

Next, create an `example.js` file
and add the following code:

```js
(async () => {
    var db = require('neo4j-driver');
  
    const URI = 'bolt://localhost:7687';
    const USER = '';
    const PASSWORD = '';
    let driver;
  
    try {
      driver = db.driver(URI, db.auth.basic(USER, PASSWORD));
      const serverInfo = await driver.getServerInfo();
      console.log('Connection established');
      console.log(serverInfo);

      const session = driver.session();

      try {
        // Clear the database
        await session.run("MATCH (n) DETACH DELETE n;");
        console.log("Database cleared.");

        // Create a user in the database
        await session.run("CREATE (:Person {name: 'Alice', age: 22});");
        console.log("Record created.");

        // Get all of the nodes
        const result = await session.run("MATCH (n) RETURN n;");
        console.log("Record matched.");

        const mark = result.records[0].get("n");
        const label = mark.labels[0];
        const name = mark.properties["name"];
        const age = mark.properties["age"];

        if (label != "Person" || name != "Alice" || age != 22) {
          console.error("Data doesn't match.");
        }

        console.log("Label: " + label);
        console.log("Name: " + name);
        console.log("Age: " + age);
      } catch (error) {
        console.error(error);
      } finally {
        session.close();
      }

      driver.close();

    } catch (err) {
      console.log(`Connection error\n${err}\nCause: ${err.cause}`);
      await driver.close();
      return;
    }
  
    await driver.close();
  })();
```

### Run the script

After running your script with node `example.js`,
you should receive the output in your terminal similar to this: 

```
Database cleared.
Record created.
Record matched.
Label: Person
Name: Alice
Age: 22
```
That means you are connected to you database and ready to visualize data
you created.

### Visualize the data

To visualize data created with the script, head over to 
`localhost:3000` or your desktop version of Memgraph Lab and run 

```MATCH (n) RETURN n;``` 

at the Query Execution tab. The query 
will visualize the created node and by clicking on it you can 
explore its properties.

![javascript-quick-start](/pages/client-libraries/javascript/javascript-quick-start.png) 

### Next steps

You now have the basic JavaScript application that connects
you to Memgraph and you are ready to start building more 
complex queries on top of it. Happy querying!

If you are a more advanced user, keep reading about database connection, 
transactional management and timeouts.

</Steps>

## JavaScript library usage

### Database connection

To connect to Memgraph, create a driver object with the appropriate 
*URI* and *AUTH* arguments. If you're running Memgraph locally, 
*URI* looks something like `bolt://localhost:7687`, and if you 
are running Memgraph on a remote server, replace localhost with 
the appropriate IP address. 

By default, you can set *username* and *password* as empty strings. 
But, if you [created a user](/configuration/security#creating-users) 
in Memgraph, make sure to provide the **correct connection details**.
 
#### Connect without authentication

By default, the Memgraph database is running without authentication, 
which means that you can connect to the database without providing any 
credentials. Here is an example of how to connect to Memgraph, that is 
running locally on port 7687, with the JavaScript client library 
**without authentication** and get the node count from the database:

```js
(async () => {
    var db = require('neo4j-driver');
  
    const URI = 'bolt://localhost:7687';
    const USER = '';
    const PASSWORD = '';
    let driver;
  
    try {
      driver = db.driver(URI, db.auth.basic(USER, PASSWORD));
      const serverInfo = await driver.getServerInfo();
      console.log('Connection established');
      console.log(serverInfo);

      const session = driver.session();

      // Count the nodes in the database
      await session.run("MATCH (n) RETURN count(n) AS num_of_nodes;");
      console.log("Database cleared.");

      driver.close();

    } catch (err) {
      console.log(`Connection error\n${err}\nCause: ${err.cause}`);
      await driver.close();
      return;
    }
  
    await driver.close();
  })();
```

#### Connect with authentication

If you created a user in Memgraph and enabled authentication by setting 
the username and password as, for example:

```CREATE USER `memgraph` IDENTIFIED BY 'password';```

then you need to provide the correct username and password when defining
authentication arguments to connect to the database. Here is an example 
of how to connect to Memgraph, that is running locally on port 7687, 
with the JavaScript client library **with authentication** and get the node 
count from the database:

```js
(async () => {
    var db = require('neo4j-driver');
  
    const URI = 'bolt://localhost:7687';
    const USER = 'memgraph';
    const PASSWORD = 'password';
    let driver;
  
    try {
      driver = db.driver(URI, db.auth.basic(USER, PASSWORD));
      const serverInfo = await driver.getServerInfo();
      console.log('Connection established');
      console.log(serverInfo);

      const session = driver.session();

      // Clear the database
      await session.run("MATCH (n) RETURN count(n) AS num_of_nodes;");
      console.log("Database cleared.");

      driver.close();

    } catch (err) {
      console.log(`Connection error\n${err}\nCause: ${err.cause}`);
      await driver.close();
      return;
    }
  
    await driver.close();
  })();
```


### Transactions management

#### Manual transactions

When querying the database, the driver automatically creates a transaction. 
A transaction is a unit of work that is either *committed* in its entirety 
or *rolled back* on failure. For more advanced use-cases, the driver provides 
functions to take full control over the **transaction lifecycle**.

Before running a transaction, you need to obtain a *session*. Sessions act 
as concrete query channels between the driver and the server, and ensure 
causal consistency is enforced. 

`session = driver.session()`

<Callout type="info">

Sessions are not thread safe: you can share the main Driver object across 
threads, but make sure each thread creates its own sessions.

</Callout>

##### Managed transactions

A transaction can contain any number of queries. As Memgraph is **ACID compliant**, 
queries within a transaction will either be executed as a whole or not at all. 
You cannot get a part of the transaction succeeding and another failing. Use 
transactions to group together related queries which work together to achieve 
a single logical database operation.

A **managed transaction** is created with the methods `session.executeRead()` and 
`session.executeWrite()`, depending on whether you want to retrieve data from 
the database or alter it. Both methods take a transaction function callback, 
which is responsible of actually carrying out the queries and processing the 
result.

```js
try {
  let session, result
  session = driver.session()  
  result = await session.executeRead(async tx => { 
    return await tx.run(`  
      MATCH (p:Person) WHERE p.name = 'Alice'
      RETURN p.name as name ORDER BY name
      `, {filter: 'Al'}
    )
  })
  for(let record of result.records) {  
    console.log(record.get('name'))
  }
} finally {
  session.close()
}

```

- Create a session. A single session can be the container for multiple 
queries. Remember to close it when done.
- The `.executeRead()` `or .executeWrite()` method is the entry point into 
a transaction.
- Use the method `Transaction.run()` to run queries, providing a Cypher 
query and an object of query parameters. Each query run returns a Result object.
- Process the result records and query summary.

Within a transaction function, a return statement results in the transaction 
being committed, while the transaction is **automatically rolled back** if 
an exception is raised.

For this reason, transaction functions should produce the same effect when run 
several times, because you do not know upfront how many times they 
are going to be executed. In practice, this means that you should not edit nor 
rely on globals, for example. Note that although transaction functions might be 
executed multiple times, the queries inside it will always run only once.

##### Explicit transactions

You can achieve full control over transactions by manually beginning one with the 
method `session.beginTransaction()`. You run queries inside an explicit transaction 
with the method `Transaction.run()`, as you do in transaction functions.

```js
let session = driver.session({ database: 'neo4j' })
let transaction = await session.beginTransaction()

// await transaction.run('<QUERY 1>')
// await transaction.run('<QUERY 2>')
// ...

await transaction.close()
await session.close()
```

The behavior and lifetime of an explicit transaction is controlled through the 
methods `Transaction.commit()`, `Transaction.rollback()`, or `Transaction.close()`.

Explicit transactions are most useful for applications that need to distribute 
Cypher execution across multiple functions for the same transaction or for 
applications that need to run multiple queries within a single transaction but 
without the automatic retries provided by managed transactions.

#### Transaction timeout

Both automatic transactions and explicit transactions 
can be provided with a timeout.

##### Automatic transation timeout

```js
session
  .run("MATCH (), (), (), () RETURN 42 AS thing;", // NOTE: A long query
    undefined,
    { timeout: 50 } // NOTE: with a short timeout
  )
  .records()
  .pipe(finalize(() => {
    session.close();
    driver.close();
  }))
  .subscribe({
    next: record => { },
    complete: () => { console.info('complete'); process.exit(1); }, // UNEXPECTED
    error: msg => console.error('Error:', msg.message), // NOTE: expected to error with server side timeout
  });

```
 
##### Explicit transaction 

```js
session
  .beginTransaction({ timeout: 50 }) // NOTE: a short timeout
  .pipe(
    mergeMap(tx =>
      tx
        .run('MATCH (),(),(),() RETURN 42 AS thing;') // NOTE: a long query
        .records()
        .pipe(
          catchError(err => { tx.rollback(); throw err; }),
          concatWith(EMPTY.pipe(finalize(() => tx.commit())))
        )
    ),
    finalize(() => { session.close(); driver.close() })
  )
  .subscribe({
    next: record => { },
    complete: () => { console.info('complete'); process.exit(1); }, // UNEXPECTED
    error: msg => console.error('Error:', msg.message), // NOTE: expected to error with server side timeout
  })
```

## Where to next?