import { Callout } from 'nextra/components'
import { Steps } from 'nextra/components'


# Java client guide 

## Quickstart 

Learn how to create a Java application that connects to the Memgraph database and executes simple queries. 
This will introduce you to the basics of Memgraph and the Java driver. This guide is based on the driver version v5 and above. Some examples may 
not be supported in older versions of the driver.

<Callout type="info"> 
Prerequisite for following this guides is to have [Java 17](https://www.oracle.com/java/technologies/downloads/) and [Docker](https://docs.docker.com/get-docker/) in your local environment. 
</Callout>

<Steps>

### Run Memgraph 

Start by running Memgraph in background. The easiest way to start Memgraph is to use Docker image, and start the container with the following command:

```bash
docker run -it -p 7687:7687 -p 3000:3000 -p 7444:7444 -e MEMGRAPH="--bolt-server-name-for-init=Neo4j/ --log-level=TRACE" memgraph/memgraph-platform
```

This will start Memgraph platform, that includes, Memgraph database, Memgraph Lab and Memgraph MAGE. Memgraph uses Bolt protocol to communicate with the Java client, 
for that you need to expose the port 7687. Memgraph Lab is a web application that you can use to visualize your data, it is available on port 3000, and port 7444 is used for
logs that are visible in the Memgraph Lab. If the Memgraph Platform is running properly, open a URL http://localhost:3000 in your browser and you should see the Memgraph Lab UI.

Make sure that you have started memgraph with `--bolt-server-name-for-init=Neo4j/`. If you do not pass the init flag, you will not be able to connect to the database, and you will get following error: 
`Exception in thread "main" org.neo4j.driver.exceptions.UntrustedServerException: Server provides no product identifier`

### Open a favorite Java IDE

Start a new empty project in your favorite Java IDE, Eclipse, IntelliJ, VScode or any other. This step will depend on what type of aplication you are trying to build, but having a bare-bone project with a single `Main.java` file is enough for this guide.

### Add a dependecies for you project 

In order to use the Java driver you will need to add dependecies. If you are using Maven, add the following dependecies to your `pom.xml` file:

```xml
<dependencies>
  <dependency>
    <groupId>org.neo4j.driver</groupId>
    <artifactId>neo4j-java-driver</artifactId>
    <version>5.11.0</version>
  </dependency>
  </dependencies>
```

If you are using Gradle, add the following dependecies to your `build.gradle` file:

```groovy
dependencies {
    implementation 'org.neo4j.driver:neo4j-java-driver:5.11.0'
}
```

### Write minimal working example 

Once you have a proper Neo4j dependency, you can start writing your first Java application. Start by addinf the the following code:

```java
package org.example;
import org.neo4j.driver.*;
import org.neo4j.driver.Record;
import org.neo4j.driver.types.Node;

import java.util.Arrays;
import java.util.List;


public class HelloMemgraph implements AutoCloseable {
    // Driiver instance used across the application
    private final Driver driver;

    // Create a driver instance, and pass the uri, username and password if required
    public HelloMemgraph(String uri, String user, String password){
        driver = GraphDatabase.driver(uri, AuthTokens.basic(user, password));
    }
    // Creating indexes 
    public void createIndexes() {
        List<String> indexes = Arrays.asList(
                "CREATE INDEX ON :Developer(id);",
                "CREATE INDEX ON :Technology(id);",
                "CREATE INDEX ON :Developer(name);",
                "CREATE INDEX ON :Technology(name);"
        );

        try (Session session = driver.session()) {
            for (String index : indexes) {
                session.run(index);
            }
        }
    }
    //Create nodes and relationships
    public void createNodesAndRealationships() {
        List<String> developerNodes = Arrays.asList(
                "CREATE (n:Developer {id: 1, name:'Andy'});",
                "CREATE (n:Developer {id: 2, name:'John'});",
                "CREATE (n:Developer {id: 3, name:'Michael'});"
        );

        List<String> technologyNodes = Arrays.asList(
                "CREATE (n:Technology {id: 1, name:'Memgraph', description: 'Fastest graph DB in the world!', createdAt: timestamp()})",
                "CREATE (n:Technology {id: 2, name:'Java', description: 'Java programming language ', createdAt: timestamp()})",
                "CREATE (n:Technology {id: 3, name:'Docker', description: 'Docker containerization engine', createdAt: timestamp()})",
                "CREATE (n:Technology {id: 4, name:'Kubernetes', description: 'Kubernetes container orchestration engine', createdAt: timestamp()})",
                "CREATE (n:Technology {id: 5, name:'Python', description: 'Python programming language', createdAt: timestamp()})"
        );

        List<String> relationships = Arrays.asList(
                "MATCH (a:Developer {id: 1}),(b:Technology {id: 1}) CREATE (a)-[r:LOVES]->(b);",
                "MATCH (a:Developer {id: 2}),(b:Technology {id: 3}) CREATE (a)-[r:LOVES]->(b);",
                "MATCH (a:Developer {id: 3}),(b:Technology {id: 1}) CREATE (a)-[r:LOVES]->(b);",
                "MATCH (a:Developer {id: 1}),(b:Technology {id: 5}) CREATE (a)-[r:LOVES]->(b);",
                "MATCH (a:Developer {id: 2}),(b:Technology {id: 2}) CREATE (a)-[r:LOVES]->(b);",
                "MATCH (a:Developer {id: 3}),(b:Technology {id: 4}) CREATE (a)-[r:LOVES]->(b);"
        );

        try (Session session = driver.session()) {
            for (String node : developerNodes) {
                session.run(node);
            }

            for (String node : technologyNodes) {
                session.run(node);
            }

            for (String relationship : relationships) {
                session.run(relationship);
            }
        }
    } 
    // Read nodes and return as Record list 
    public List<Record> readNodes() {
        String query = "MATCH (n:Technology{name: 'Memgraph'}) RETURN n;";
        try (Session session = driver.session()) {
            Result result = session.run(query);
            return result.list();
        }

    }


    public static void main(String[] args) {

        try (var helloMemgraph = new HelloMemgraph("bolt://localhost:7687", "", "")){
            // Create indexes
            helloMemgraph.createIndexes();
            // Create nodes and relationships
            helloMemgraph.createNodesAndRealationships();
            // Read nodes
            var result = helloMemgraph.readNodes();
            // Process results
            for (Record node : result) {
                Node n = node.get("n").asNode();
                System.out.println(n); // Node type
                System.out.println(n.asMap()); // Node properties
                System.out.println(n.id()); // Node internal ID
                System.out.println(n.labels()); // Node labels
                System.out.println(n.get("id").asLong()); // Node user defined id property
                System.out.println(n.get("name").asString()); // Node user defined name property
                System.out.println(n.get("description").asString()); // Node user defined description property
                //System.out.println(n.get("createdAt").asLocalDateTime()); // Node user defined createdAt property
            }
        }
    }
```
This is code snippet is a minimal working example that will create a connection to the Memgraph database via Java driver, create indexes, create nodes and relationships, and read the data back. Take a look at the code in details, 
all the comments are there to help you understand what is happening. More details about code snippet will be explained in the [Java client API usage and examples](#java-client-api-usage-and-examples) section.


### Run the application

Once code is in place, you should be able to run the application. If you are using an IDE, you can run the application from there. If everything is working properly, you should see the following output:

```text
node<76>
{name=Memgraph, createdAt=1693389566657284, description=Fastest graph DB in the world!, id=1}
76
[Technology]
1
Memgraph
Fastest graph DB in the world!
```

### Visualize the data 
If you want to visualize what you created in the database with the code snippet from above, head over to localhost:3000 and run `MATCH path=(n)-[p]-(m) RETURN path` at the Query Execution tab. 
That query will visualize the created nodes and relationships and by clicking on it you can explore node and relationship properties.

![java-quick-start](/pages/client-libraries/java/java-quick-start.png)

### Next steps 

This makes a good starting point for your Java application. You can now start building your application on top of this example. For more information on how to use the Java driver, 
continue reading the guide under [Java client API usage and examples](#Java-client-api-usage-and-examples), by the section that interest you the most. 


</Steps>


<Callout type="info">
Memgraph created [Bolt Java Driver](https://github.com/memgraph/bolt-java-driver) which can be used to connect to a running Memgraph instance. We still recommend you use the above mentioned driver.
</Callout>


## Java client API usage and examples

## Database connection 

Once the database is running, and you have proper code that uses driver, you will be able to connect and query Memgraph. For Java, Memgraph currently depends on the (Neo4j Java driver)[https://github.com/neo4j/neo4j-java-driver]. Memgraph and Neo4j both support Bolt protocol and Cypher queries, 
which means that you can use the same driver to connect to both databases. This is very convenient if you want to switch between the two databases. 

#### Connect without authentication (default)

By default, the Memgraph database is running without authentication, which means that you can connect to the database without providing any credentials. 
To connect to Memgraph, create a driver object with the appropriate URI and AUTH arguments. If you're running Memgraph locally, URI looks something like `bolt://localhost:7687`, and if you are running Memgraph on a remote server, 
replace `localhost` with the appropriate IP address. 
If you ran Memgraph on port different than 7687, don't forget to update that in the URI too. 
By default, you can set username and password in the AUTH argument as empty strings. But, if you [created a user](/configuration/security/#creating-user) in Memgraph, make sure to provide the correct connection details.

To connect a Java driver to the Memgraph database, you can use the following snippet: 

```java
import org.neo4j.driver.AuthTokens;
import org.neo4j.driver.Driver;
import org.neo4j.driver.GraphDatabase;

public class HelloMemgraph implements AutoCloseable {
    private final Driver driver;

    public HelloMemgraph(String uri, String user, String password) {
        driver = GraphDatabase.driver(uri, AuthTokens.basic(user, password));
    }

    @Override
    public void close() throws RuntimeException {
        driver.close();
    }

    public static void main(String[] args) {
        try (var helloMemgraph = new HelloMemgraph("bolt://localhost:7687", "", "")) {
            // Use the driver
        }
    }
}
```
Notice that `AuthTokens.basic` takes two arguments, the first is `username` and the second is `password`. 
For both username and password, you can pass an empty string, this means that you are connecting without authentication.


#### Connect with authentication

If you have enabled authentication in Memgraph by setting a proper username and password, like this: 

```Cypher
CREATE USER `memgraph` IDENTIFIED BY 'memgraph';
```

Then, you can connect to the database with the following snippet:

```java

import org.neo4j.driver.AuthTokens;
import org.neo4j.driver.Driver;
import org.neo4j.driver.GraphDatabase;

public class HelloMemgraph implements AutoCloseable {
    private final Driver driver;

    public HelloMemgraph(String uri, String user, String password) {
        driver = GraphDatabase.driver(uri, AuthTokens.basic(user, password));
    }

    @Override
    public void close() throws RuntimeException {
        driver.close();
    }

    public static void main(String[] args) {
      String uri = "bolt://localhost:7687";
      String username = "memgraph";
      String password = "memgraph";
      try (var helloMemgraph = new HelloMemgraph(uri, username, password)) {
          // Use the driver
      }
    }
}
```

If you get and error like this: 
```Exception in thread "main" org.neo4j.driver.exceptions.SecurityException: Authentication failure```

Then you have probably enabled authentication in Memgraph, but you are trying to connect without authentication.

#### Java client connection lifecycle management 

It is sufficient to open a single client connection to Memgraph and use it for all your queries. Once client connection is open, we can use 
Java AutoCloseable interface to manage the lifecycle of the client. The lifecycle of the client is tied to your application lifecycle.

So the following code implementation of AutoCloseable, will make sure to close the client connection once the application is finished: 

```java
@Override
public void close() throws RuntimeException {
    driver.close();
}
```

Driver is thread safe, and can be reused between different threads if needed.


### Query the database 

After connection your driver to the Memgraph you can start running some queries, the simplest way to run the query is via `ExecuteQuery` method that has an automatic transaction management. 

#### Run a create query 

Now here is the simple create query you can run: 

```java
public void createNode() {
    try (Session session = driver.session(SessionConfig.forDatabase("memgraph"))) {
        session.writeTransaction(tx -> {
            tx.run("CREATE (n:Technology {name:'Memgraph'})");
            return null;
        });
    }
}
```

The session object takes a SessionConfig object as its argument. The SessionConfig object is used to specify the database name, and other session configuration options. Session API supports writeTransaction and readTransaction methods.
TODO EXPLAIN BETTER: The writeTransaction method of a Neo4j Session object takes a TransactionWork functional interface as its argument. The TransactionWork interface has a single method execute, which takes a Transaction object as its argument and returns a value of type T. 

#### Run a read query 
```
public void readNode() {
    try (Session session = driver.session(SessionConfig.forDatabase("memgraph"))) {
        List<Record> result = session.readTransaction(tx -> {
            Result queryResult = tx.run("MATCH (n:Technology{name: 'Memgraph'}) RETURN n");
            List<Record> records = queryResult.list();
            return records;
        });
        System.out.println(result);

        // Print each node as map
        for (Record record : result) {
            System.out.println(record.get("n").asMap());
        }
    }
}
```

#### Run a query with parameters 

If you want to pass a map of properties to the query, you can do it like this:

```
    public void createNodeWithProperties() {
        try (Session session = driver.session(SessionConfig.forDatabase("memgraph"))) {
            Map<String, Object> properties = new HashMap<>();
            properties.put("name", "Memgraph");
            properties.put("type", "graph database");

            session.writeTransaction(tx -> {
                tx.run("CREATE (n:Technology {name: $name, type: $type})", properties);
                return null;
            });
        }
    }
```

This way your queries won't contain hard-coded values. 

### Process the returned results from 

In order to read results and serve them back to you Java application you need to handle them. Java is statically typed language and proper types need to be handled. 
Depending on the type of the request you made, you can get different results back. Lets go over a few examples how you can interpret the results. 

#### Processing Node results 

Run the following query:

```java
public List<Record> readNodes() {
    String query = "MATCH (n:Technology {name: 'Memgraph'}) RETURN n;";
    try (Session session = driver.session()) {
        Result result = session.run(query);
        return result.list();
    }

}
```

Records field contains all the records returned by the query. To process the results, you can iterate over the records and access the fields you need. 
Here is the example: 

```java
for (Record record : result) {
    System.out.println(record.get("n").asMap());
}
```
```text
{name=Memgraph, createdAt=1693389566657284, description=Fastest graph DB in the world!, id=1}
```


Lets break down the result. So for each returned record, it is getting converted to a map, now we can access the `n` field, which is a node returned from a query. The returned record and all its properties are of type `any`. This means that you have to cast them to the relevant Go type if you want to use methods/features defined on such types. 
To access individual properties of the node you have following options: 

```java
Node n = node.get("n").asNode();
System.out.println(n); // node<65>
System.out.println(n.asMap()); // {name=Memgraph, createdAt=1693400712958077, description=Fastest graph DB in the world!, id=1}
System.out.println(n.id()); // 65
System.out.println(n.labels()); [Technology]
System.out.println(n.get("id").asLong()); // 1
System.out.println(n.get("name").asString()); // Memgraph
System.out.println(n.get("description").asString()); // Fastest graph DB in the world!
//System.out.println(n.get("createdAt").asLocalDateTime()); // Node user defined createdAt property
```
TODO fix the createdAt property, it is not working properly.

### Processing Relationship results

You can also get a relationship back from the query. Here is the example: 

```java
public void createRelationship() {
    String query = "CREATE (d:Developer {name: 'John Doe'})-[:LOVES {id:99}]->(t:Technology {id: 1, name:'Memgraph', description: 'Fastest graph DB in the world!', createdAt: date()})";
    try (Session session = driver.session(SessionConfig.forDatabase("memgraph"))) {
        session.writeTransaction(tx -> {
            tx.run(query);
            return null;
        });
    }
}

public List<Record> readRelationship() {
    String query = "MATCH (d:Developer)-[r:LOVES]->(t:Technology) RETURN r";
    try (Session session = driver.session(SessionConfig.forDatabase("memgraph"))) {
        List<Record> result = session.readTransaction(tx -> {
            Result queryResult = tx.run(query);
            List<Record> records = queryResult.list();
            return records;
        });
        return result;
    }
}


```java 
    for (Record rel : records) {
        Relationship relationship = rel.get("r").asRelationship();
        System.out.println(relationship);
        System.out.println(relationship.asMap());
        System.out.println(relationship.id());
        System.out.println(relationship.type());
        System.out.println(relationship.startNodeId());
        System.out.println(relationship.endNodeId());
        System.out.println(relationship.get("id").asLong());
    }
```
You can access the relationship properties in the same way as you access the node properties. startNodeId and endNodeId are the internal IDs of the start and end node of the relationship.


### Processing Path results 


You can also get a path back from the query. Here is the example: 

```java
public List<Record> readPath() {
    String query = "MATCH path=(d:Developer)-[r:LOVES]->(t:Technology) RETURN path";
    try (Session session = driver.session(SessionConfig.forDatabase("memgraph"))) {
        List<Record> result = session.readTransaction(tx -> {
            Result queryResult = tx.run(query);
            List<Record> records = queryResult.list();
            return records;
        });
        return result;
    }
}
```

```java
  for (Record path : path_records) {
      Path p = path.get("path").asPath();
      System.out.println(p);
      System.out.println(p.start());
      System.out.println(p.end());
      System.out.println(p.length());
      System.out.println(p.nodes());
      System.out.println(p.relationships());
  }
```


Path will contain nodes and relationships, that can be accessed in the same way as in the previous examples.

#### Types mapping Cypher and Java 

 Here is the full table of the mapping between Memgraph Cypher types and the types used in the Java driver:

|  Cypher Type | Driver Type        |
|-------------:|:-------------------|
|          Null| null               |
|       String | String             |
|      Boolean | boolean            |
|      Integer | long               |
|        Float | double             |
|         List | List<Object>       |
|          Map | Map<String, Object>|
|         Node | Node               |
| Relationship | Relationship       |
|         Path | Path               |
|     Duration | IsoDuration        |
|         Date | LocalDate          |
|    LocalTime | LocalTime          |
|LocalDateTime | LocalDateTime      |


Keep in mind that Memgraph does not support Timezones, ByteArray and Point at the moment. 

### Transaction management

#### Simple transaction management  

Simple transaction managment provide a standard blocking style API for Cypher execution. Simple transaction managment provides the easiest programming style to work with since API calls are executed in a strictly sequential fashion.

##### Session management

Before doing any transaction mangment, you need to do is to create a session. Session is a specific connection to the database, that is lightweight and should be closed after the 
wanted queries has been executed. There is no need to keep the session open for the whole duration of the application. To open a session, use the code snippet below: 

```java
try (Session session = driver.session(...)) {
    // transactions go here
}
```

 This Java try-with-resources statement will automatically close the session once the code block is finished. Sessions are not thread safe, so you should create a new session for each thread.

With sessions, you can use the following transaction management methods:

 - `writeTransaction` - executes a managed transaction workload in write access mode with retry logic.
 - `readTransaction` - executes a managed transaction workload in read access mode with retry logic.
 - `run` - executes a implicit auto-commit transaction and returns result.


<Callout type="warning">

Error with multicommand transactions

`Index manipulation not allowed in multicommand transactions` is a kind of error you might experience. To fix that, use `run` method, for [implicit (or auto-commit) transactions](#implicit-transactions) instead.

</Callout>

##### Managed transactions

Let's take a look into the basic example if you want to read data from the database.
Now you can run simple transaction via `writeTransaction` like this: 

```java
public void createNode() {
    try (Session session = driver.session(SessionConfig.forDatabase("memgraph"))) {
        session.writeTransaction(tx -> {
            tx.run("CREATE (n:Technology {name:'Memgraph'})");
            tx.run("CREATE (n:Technology {name:'Java'})");
            //Some other queries 
            return null;
        });
    }
}
```
As you can see previus examples from guide has used the simple transaction management, so take a look the examples of `readTransactions` above.


##### Implicit transactions 

Implicit auto commit queries are the simplest way to run a Cypher query since they won't be automatically retried as with writeTransaction and readTransaction. 
With implicit auto commit transactions, you don't have the same control of transaction as with explicit transactions. 

Here is the example of implicit transaction:
```java
public void createNode() {
    try (Session session = driver.session(SessionConfig.forDatabase("memgraph"))) {
        session.run("CREATE (n:Technology {name:'Memgraph'})");
    }
}
```

As you can see in this case you can run a simple query without any transaction management. This simplifys the experience but you lose some flexibility when running the queries. 

#### Asynchronous transaction managment

##### Session management

TODO Check why this is not working properly 

Asynchronous sessions provide a API to work with futures. This allows client applications to work within asynchronous code bases. Asynchronous sessions are not thread safe, so you should create a new session for each thread.
Session lifetime begins with session construction, session is typicaly closed automatically when all results are consumed. 

The session is opened with the following code snippet: 

```java
 var session = driver.session(AsyncSession.class);
```

Via async session API you can use following transaction management methods:

 - `writeTransactionAsync` - executes a manged transaction workload in write access mode with retry logic.
 - `readTransactionAsync` - executes a managed transaction workload in read access mode with retry logic.
 - `runAsync` - executes a implicit auto-commit transaction and returns result.


##### Managed transactions 


Let's take a look into the basic example if you want to read data from the database via Async session API:

```java
public CompletionStage<ResultSummary> readNodesAsync() {
    String query = "MATCH (n:Technology {name: 'Memgraph'}) RETURN n;";
    var session = driver.session(AsyncSession.class);

    return session.executeReadAsync(tx -> tx.runAsync(query)
            .thenCompose(cursor -> cursor.forEachAsync(record ->
                    // asynchronously print every record
                    System.out.println(record.get(0).asString()))));

}
```

TODO: Write example for writeTransactionAsync


##### Implicit auto-commit asynchronous transactions

Implicit auto commit queries are the simplest way to run a Cypher query since they won't be automatically retried as with writeTransactionAsync and readTransactionAsync.

Here is the example of implicit transaction:

```java
public CompletionStage<ResultSummary> createNodeAsync() {
    String query = "CREATE (n:Technology {name:'Memgraph'})";
    var session = driver.session(AsyncSession.class);

    return session.runAsync(query)
            .thenCompose(ResultCursor::consumeAsync)
            .whenComplete((resultSummary, error) -> session.closeAsync());
}
```




