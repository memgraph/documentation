import { Callout } from 'nextra/components'
import { Steps } from 'nextra/components'


# Java client guide 

Learn how to create a Java application application that connects to the Memgraph database and executes simple queries. 

Memgraph currently depends on the [Neo4j Java driver](https://neo4j.com/docs/java-manual/current/) for Java programming language. 
Memgraph and Neo4j both support Bolt protocol and Cypher queries, which means that same driver can be used to connect to both databases. 
This is very convenient if there is a need to switch between the two databases.  This guide is based on the driver version v5 and above. Some examples may 
not be supported in older versions of the driver.


## Quickstart 

The following guide will demonstrate how to start Memgraph, connect to Memgraph, seed the database with data, run simple read and write queries. 


Prerequisite that are necessary and sould be installed in your local enviroment are following: 
- [Java 17](https://www.oracle.com/java/technologies/downloads/)
- [Docker](https://docs.docker.com/get-docker/)

This won't be covered in this guide, but you can find more information on how to install them in the links above.

<Steps>

### Run Memgraph 

Start by running Memgraph in the background. The easiest way to install and run Memgraph is by using Docker. Start the container with the following command:

```bash
docker run -it -p 7687:7687 -p 3000:3000 -p 7444:7444 --name memgraph -e MEMGRAPH="--bolt-server-name-for-init=Neo4j/ --log-level=TRACE" memgraph/memgraph-platform
```

This command above will start [Memgraph Platform](/getting-started/install-memgraph/docker#install-memgraph-platform), which includes,[Memgraph database](/getting-started/install-memgraph/docker#other-available-docker-images), [Memgraph Lab](/data-visualization#quick-start) and [Memgraph MAGE](/advanced-algorithms#quick-start). Memgraph uses Bolt protocol to communicate with the client using the exposed 7687 port. 
Memgraph Lab is a web application that can be used to visualize your data, it is available on port 3000, and port 7444 is used for the logs that are visible in the Memgraph Lab, so both port 3000 for LAB and 7444 for logs need to be open. If the Memgraph Platform is running properly, open a URL http://localhost:3000 in your browser and you should see the Memgraph Lab UI. 

For more information visit the getting started guide on [how to run Memgraph with Docker](/getting-started/install-memgraph/docker).


<Callout type="warning">

Make sure that you have started memgraph with `--bolt-server-name-for-init=Neo4j/`. If you do not pass the init flag, you will not be able to connect to the database, and you will get following error: 
Exception in thread "main" org.neo4j.driver.exceptions.UntrustedServerException: Server provides no product identifier

</Callout>

### Open a favorite Java IDE

Start a new empty project in your favorite Java IDE, Eclipse, IntelliJ, VScode or any other. This step will depend on what type of aplication you are trying to build, but having a bare-bone project with a single `Main.java` file is enough for this guide.

### Add a dependecies for you project 

In order to use the Java driver you will need to add dependecies. If you are using Maven, add the following dependecies to your `pom.xml` file:

```xml
<dependencies>
  <dependency>
    <groupId>org.neo4j.driver</groupId>
    <artifactId>neo4j-java-driver</artifactId>
    <version>5.11.0</version>
  </dependency>
  </dependencies>
```

If you are using Gradle, add the following dependecies to your `build.gradle` file:

```groovy
dependencies {
    implementation 'org.neo4j.driver:neo4j-java-driver:5.11.0'
}
```

### Write a minimal working example 

Once you have a proper Neo4j dependency, you can start writing your first Java application. Start by adding the the following code:

```java
package org.example;
import org.neo4j.driver.*;
import org.neo4j.driver.Record;
import org.neo4j.driver.types.Node;

import java.util.Arrays;
import java.util.List;


public class HelloMemgraph implements AutoCloseable {
    // Driiver instance used across the application
    private final Driver driver;

    // Create a driver instance, and pass the uri, username and password if required
    public HelloMemgraph(String uri, String user, String password){
        driver = GraphDatabase.driver(uri, AuthTokens.basic(user, password));
    }
    // Creating indexes 
    public void createIndexes() {
        List<String> indexes = Arrays.asList(
                "CREATE INDEX ON :Developer(id);",
                "CREATE INDEX ON :Technology(id);",
                "CREATE INDEX ON :Developer(name);",
                "CREATE INDEX ON :Technology(name);"
        );

        try (Session session = driver.session()) {
            for (String index : indexes) {
                session.run(index);
            }
        }
    }
    //Create nodes and relationships
    public void createNodesAndRealationships() {
        List<String> developerNodes = Arrays.asList(
                "CREATE (n:Developer {id: 1, name:'Andy'});",
                "CREATE (n:Developer {id: 2, name:'John'});",
                "CREATE (n:Developer {id: 3, name:'Michael'});"
        );

        List<String> technologyNodes = Arrays.asList(
                "CREATE (n:Technology {id: 1, name:'Memgraph', description: 'Fastest graph DB in the world!', createdAt: timestamp()})",
                "CREATE (n:Technology {id: 2, name:'Java', description: 'Java programming language ', createdAt: timestamp()})",
                "CREATE (n:Technology {id: 3, name:'Docker', description: 'Docker containerization engine', createdAt: timestamp()})",
                "CREATE (n:Technology {id: 4, name:'Kubernetes', description: 'Kubernetes container orchestration engine', createdAt: timestamp()})",
                "CREATE (n:Technology {id: 5, name:'Python', description: 'Python programming language', createdAt: timestamp()})"
        );

        List<String> relationships = Arrays.asList(
                "MATCH (a:Developer {id: 1}),(b:Technology {id: 1}) CREATE (a)-[r:LOVES]->(b);",
                "MATCH (a:Developer {id: 2}),(b:Technology {id: 3}) CREATE (a)-[r:LOVES]->(b);",
                "MATCH (a:Developer {id: 3}),(b:Technology {id: 1}) CREATE (a)-[r:LOVES]->(b);",
                "MATCH (a:Developer {id: 1}),(b:Technology {id: 5}) CREATE (a)-[r:LOVES]->(b);",
                "MATCH (a:Developer {id: 2}),(b:Technology {id: 2}) CREATE (a)-[r:LOVES]->(b);",
                "MATCH (a:Developer {id: 3}),(b:Technology {id: 4}) CREATE (a)-[r:LOVES]->(b);"
        );

        try (Session session = driver.session()) {
            for (String node : developerNodes) {
                session.run(node);
            }

            for (String node : technologyNodes) {
                session.run(node);
            }

            for (String relationship : relationships) {
                session.run(relationship);
            }
        }
    } 
    // Read nodes and return as Record list 
    public List<Record> readNodes() {
        String query = "MATCH (n:Technology{name: 'Memgraph'}) RETURN n;";
        try (Session session = driver.session()) {
            Result result = session.run(query);
            return result.list();
        }

    }

    public static void main(String[] args) {

        try (var helloMemgraph = new HelloMemgraph("bolt://localhost:7687", "", "")){
            // Create indexes
            helloMemgraph.createIndexes();
            // Create nodes and relationships
            helloMemgraph.createNodesAndRealationships();
            // Read nodes
            var result = helloMemgraph.readNodes();
            // Process results
            for (Record node : result) {
                Node n = node.get("n").asNode();
                System.out.println(n); // Node type
                System.out.println(n.asMap()); // Node properties
                System.out.println(n.id()); // Node internal ID
                System.out.println(n.labels()); // Node labels
                System.out.println(n.get("id").asLong()); // Node user defined id property
                System.out.println(n.get("name").asString()); // Node user defined name property
                System.out.println(n.get("description").asString()); // Node user defined description property
            }
        }
    }
```
This code snippet is a minimal working example that will create a connection to the Memgraph database via Java driver, create indexes, create nodes and relationships, and read the data back. Take a look at the code in detail as
it includes the comments to help you understand it. More details about the code snippet will be explained in the [Java client API usage and examples](#java-client-api-usage-and-examples) section.


### Run the application

Once code is in place, you should be able to run the application. If you are using an IDE, you can run the application from there. If everything is working properly, you should see the following output:

```text
node<76>
{name=Memgraph, createdAt=1693389566657284, description=Fastest graph DB in the world!, id=1}
76
[Technology]
1
Memgraph
Fastest graph DB in the world!
```

### Visualize the data 
To visualize objects created in the database with the the code snippet above, head over to [http://localhost:3000/](http://localhost:3000/) and run `MATCH path=(n)-[p]-(m) RETURN path` in the *Query Execution* tab. 
That query will visualize the created nodes and relationships. By clicking on a node or relationship, you can explore different properties.

![java-quick-start](/pages/client-libraries/java/java-quick-start.png)

### Next steps 

This makes a good starting point for Java application. For more information on how to use the Java driver, 
continue reading the guide under [Java client API usage and examples](#Java-client-api-usage-and-examples). 

</Steps>

<Callout type="info">
Memgraph created [Bolt Java Driver](https://github.com/memgraph/bolt-java-driver) which can be used to connect to a running Memgraph instance. But we still recommend you use the above mentioned driver.
</Callout> 


## Java client API usage and examples

After a brief [Quickstart guide](#quickstart), this section will go into more detail on how to use the Java driver API, explain code snippets, and provide more examples. Feel free to skip to the section that interests you the most.

### Database connection 

Once the database is running, and driver is installed or available in Java, you should be able to connect to the database with one of two ways:

- [Connect without authentication (default)](#connect-without-authentication-default)
- [Connect with authentication](#connect-with-authentication)


#### Connect without authentication (default)

By default, the Memgraph database is running without authentication, which means that you can connect to the database without providing any credentials (username and password).
To connect to Memgraph, create a driver object with the appropriate URI and credentials arguments. If you're running Memgraph locally, the URI should be similar to `bolt://localhost:7687`, and if you are running Memgraph on a remote server, 
replace `localhost` with the appropriate IP address. 
If you ran Memgraph on port different than 7687, do not forget to update that in the URI too. 


By default, you can set username and password in the `AuthTokens.basic("", "")` argument as empty strings. This means that you are connecting without authentication.

To connect a Java driver to the Memgraph database, you can use the following snippet: 

```java {10-12}
import org.neo4j.driver.AuthTokens;
import org.neo4j.driver.Driver;
import org.neo4j.driver.GraphDatabase;

public class HelloMemgraph implements AutoCloseable {
    private final Driver driver;

    public HelloMemgraph(String uri, String user, String password) {
        driver = GraphDatabase.driver(uri, AuthTokens.basic(user, password));
    }

    @Override
    public void close() throws RuntimeException {
        driver.close();
    }

    public static void main(String[] args) {
        try (var helloMemgraph = new HelloMemgraph("bolt://localhost:7687", "", "")) {
            // Use the driver
        }
    }
}
```
Notice that `AuthTokens.basic` takes two arguments, the first is `username` and the second is `password`. 
For both username and password, you can pass an empty string, this means that you are connecting without authentication.


#### Connect with authentication

In order to set up authentication in Memgraph, you need to set up a user that has `username` and `password`. In Memgraph you can set a username and password by executing the following query: 

```cypher
CREATE USER `memgraph` IDENTIFIED BY 'memgraph';
```

Then, you can connect to the database with the following snippet:

```java
import org.neo4j.driver.AuthTokens;
import org.neo4j.driver.Driver;
import org.neo4j.driver.GraphDatabase;

public class HelloMemgraph implements AutoCloseable {
    private final Driver driver;

    public HelloMemgraph(String uri, String user, String password) {
        driver = GraphDatabase.driver(uri, AuthTokens.basic(user, password));
    }

    @Override
    public void close() throws RuntimeException {
        driver.close();
    }

    public static void main(String[] args) {
      String uri = "bolt://localhost:7687";
      String username = "memgraph";
      String password = "memgraph";
      try (var helloMemgraph = new HelloMemgraph(uri, username, password)) {
          // Use the driver
        }
    }
}
```

If you receive the following error: 

```Exception in thread "main" org.neo4j.driver.exceptions.SecurityException: Authentication failure```

The error indicates that you have probably enabled authentication in Memgraph, but are trying to connect without authentication. For more details on how to set authentication further, visit the [Memgraph authentication guide](/configuration/security/#creating-user).

#### Java client connection lifecycle management 

Once driver connection to Memgraph is established, it doesn't need to be closed. It's sufficient to open a single client connection to Memgraph and use it for all queries. Once client connection is open, we can use 
Java AutoCloseable interface to manage the lifecycle of the client. The lifecycle of the client is tied to your application lifecycle.

The following implementation of `AutoCloseable` interface will make sure to close the client connection once the application is finished: 

```java
@Override
public void close() throws RuntimeException {
    driver.close();
}
```

Keep in mind that driver object is thread safe, and can be reused between different threads. 

### Query the database 

After connecting your driver to the Memgraph you can start running some queries, the simplest way to run the query is via writeTransaction and readTransaction methods.

#### Run a write query 

The following query will create a node inside the database: 

```java
public void createNode() {
    try (Session session = driver.session(SessionConfig.forDatabase("memgraph"))) {
        session.writeTransaction(tx -> {
            tx.run("CREATE (n:Technology {name:'Memgraph'})");
            return null;
        });
    }
}
```

The session object takes a SessionConfig object as its argument. The SessionConfig object is used to specify the database name, and other session configuration options. Session API supports writeTransaction and readTransaction methods.
The writeTransaction method of a Neo4j Session object takes a TransactionWork functional interface as its argument. The TransactionWork interface has a single method execute, which takes a Transaction object as its argument and returns a value of type T, void in this case. 

#### Run a read query 

Similar to the write query, there is a `readTranasction()` method that can be used to run read queries. The difference is that read will actually return the results of the query.

The following query will read data from the database: 

```java
public void readNode() {
    try (Session session = driver.session(SessionConfig.forDatabase("memgraph"))) {
        List<Record> result = session.readTransaction(tx -> {
            Result queryResult = tx.run("MATCH (n:Technology{name: 'Memgraph'}) RETURN n");
            List<Record> records = queryResult.list();
            return records;
        });
        System.out.println(result);

        // Print each node as map
        for (Record record : result) {
            System.out.println(record.get("n").asMap());
        }
    }
}
```

In this query, each `Record` contains a `Node` accessible by the `asMap()` method.

#### Run a query with parameters 

If you want to pass a property map to the query, you can do it like this:

```
public void createNodeWithProperties() {
    try (Session session = driver.session(SessionConfig.forDatabase("memgraph"))) {
        Map<String, Object> properties = new HashMap<>();
        properties.put("name", "Memgraph");
        properties.put("type", "graph database");

        session.writeTransaction(tx -> {
            tx.run("CREATE (n:Technology {name: $name, type: $type})", properties);
            return null;
        });
    }
}
```

Using this approach, the queries will not contain hard-coded values, they can be more dynamic.

### Process the results

To read results and serve them back to the Java application, they need need to be handled. Java is a statically typed language and proper types need to be handled. 
Depending on the type of request made, you can receive different results. Let's go over a few basic examples of how to handle different types and access properties of the returned results. 

#### Proces the Node results 

Run the following query:

```java
public List<Record> readNodes() {
    String query = "MATCH (n:Technology {name: 'Memgraph'}) RETURN n;";
    try (Session session = driver.session()) {
        Result result = session.run(query);
        return result.list();
    }

}
```

Records field contains all the records returned by the query. To process the results, you can iterate over the records and access the fields you need. 

Here is the example: 

```java
for (Record record : result) {
    System.out.println(record.get("n").asMap());
}
```
```text
{name=Memgraph, createdAt=1693389566657284, description=Fastest graph DB in the world!, id=1}
```

Lets break down the result. So for each returned `Record` from the database, it is getting converted to a map, now we can access the `n` field, which is a `Node` returned from a query. This means that you have to cast them to the relevant Java types.  

To access individual properties of the `Node`, you have the following options: 

```java
Node n = node.get("n").asNode();
System.out.println(n); // node<65>
System.out.println(n.asMap()); // {name=Memgraph, createdAt=1693400712958077, description=Fastest graph DB in the world!, id=1}
System.out.println(n.id()); // 65
System.out.println(n.labels()); // [Technology]
System.out.println(n.get("id").asLong()); // 1
System.out.println(n.get("name").asString()); // Memgraph
System.out.println(n.get("description").asString()); // Fastest graph DB in the world!
```

You can access all `Node` properties by casting and accessing `Node`. Keep in mind that the `id()` returns the internal ID of the node, which is not the same as the user-defined ID, and it should not 
be used for any application-level logic.

### Processing Relationship results

You can also receive a `Relationship` from the query. For example: 

Here is the example: 

```java
//Create relationship
public void createRelationship() {
    String query = "CREATE (d:Developer {name: 'John Doe'})-[:LOVES {id:99}]->(t:Technology {id: 1, name:'Memgraph', description: 'Fastest graph DB in the world!', createdAt: date()})";
    try (Session session = driver.session(SessionConfig.forDatabase("memgraph"))) {
        session.writeTransaction(tx -> {
            tx.run(query);
            return null;
        });
    }
}
//Read relationship
public List<Record> readRelationship() {
    String query = "MATCH (d:Developer)-[r:LOVES]->(t:Technology) RETURN r";
    try (Session session = driver.session(SessionConfig.forDatabase("memgraph"))) {
        List<Record> result = session.readTransaction(tx -> {
            Result queryResult = tx.run(query);
            List<Record> records = queryResult.list();
            return records;
        });
        return result;
    }
}

//Process results
for (Record rel : records) {
    Relationship relationship = rel.get("r").asRelationship();
    System.out.println(relationship);
    System.out.println(relationship.asMap());
    System.out.println(relationship.id());
    System.out.println(relationship.type());
    System.out.println(relationship.startNodeId());
    System.out.println(relationship.endNodeId());
    System.out.println(relationship.get("id").asLong());
}
```
You can access the `Relationship` properties in the same way as you access the `Node` properties. Id values from `startNodeId()` and `endNodeId()` are the internal IDs of the start and end node of the relationship, do not used them in your application logic.


### Processing Path results 

You can receive `Path` from the database, using the following construct:

```java
public List<Record> readPath() {
    String query = "MATCH path=(d:Developer)-[r:LOVES]->(t:Technology) RETURN path";
    try (Session session = driver.session(SessionConfig.forDatabase("memgraph"))) {
        List<Record> result = session.readTransaction(tx -> {
            Result queryResult = tx.run(query);
            List<Record> records = queryResult.list();
            return records;
        });
        return result;
    }
}

for (Record path : path_records) {
    Path p = path.get("path").asPath();
    System.out.println(p);
    System.out.println(p.start());
    System.out.println(p.end());
    System.out.println(p.length());
    System.out.println(p.nodes());
    System.out.println(p.relationships());
}
```


Path will contain [Nodes](#process-the-node-result) and [Relationships[#process-the-relationship-result], that can be accessed in the same way as in the previous examples, by casting them to the relevant type.

#### Types mapping Cypher and Java 

 Here is the full table of the mapping between Memgraph Cypher types and the types used in the Java driver:

|  Cypher Type | Driver Type        |
|-------------:|:-------------------|
|          Null| null               |
|       String | String             |
|      Boolean | boolean            |
|      Integer | long               |
|        Float | double             |
|         List | List<Object>       |
|          Map | Map<String, Object>|
|         Node | Node               |
| Relationship | Relationship       |
|         Path | Path               |
|     Duration | IsoDuration        |
|         Date | LocalDate          |
|    LocalTime | LocalTime          |
|LocalDateTime | LocalDateTime      |


Keep in mind that Memgraph does not support Timezones, ByteArray and Point at the moment. 

### Transaction management

Transaction is a unit of work that is executed on the database, it could be some basic read, write or complex set of steps in form of series of queries. There can be multiple ways to mange transaction, but usually, they are managed automatically by the driver or manually by the explicit code steps. Transaction management defines how to handle the transaction, when to commit, rollback, or terminate it.

#### Simple transaction management  

Simple transaction managment provide a standard blocking style API for Cypher execution. Simple transaction managment provides the easiest programming style to work with since API calls are executed in a strictly sequential fashion.

##### Session management

Before doing any transaction mangment, you need to do is to create a session. Session is a specific connection to the database, that can live for certian time span. Session connection is lightweight and should be closed after the 
wanted queries has been executed. There is no need to keep the session open for the whole duration of the application. To open a session, use the code snippet below: 

```java
try (Session session = driver.session(...)) {
    // transactions go here
}
```

 This Java try-with-resources statement will automatically close the session once the code block is finished. Sessions are not thread safe, so you should create a new session for each thread.

With sessions, you can use the following transaction management methods:

 - `writeTransaction` - executes a managed explicit transaction workload in write access mode with retry logic.
 - `readTransaction` - executes a managed explicit transaction workload in read access mode with retry logic.
 - `run` - executes a implicit auto-commit transaction and returns result.


<Callout type="warning">

Error with multicommand transactions

If you experience `Index manipulation not allowed in multicommand transactions` error,  use [implicit (or auto-commit) transactions](#implicit-transactions) instead.

</Callout>

##### Managed transactions

Let's take a look into the basic example if you want to read data from the database.
Now you can run simple transaction via `writeTransaction` like this: 

```java
public void createNode() {
    try (Session session = driver.session(SessionConfig.forDatabase("memgraph"))) {
        session.writeTransaction(tx -> {
            tx.run("CREATE (n:Technology {name:'Memgraph'})");
            tx.run("CREATE (n:Technology {name:'Java'})");
            //Some other queries 
            return null;
        });
    }
}
```
As you can see previus examples from guide has used the simple transaction management, it alows you to run multiple queries in a single transaction and have a control over the transaction. You could have multiple logic blocks in the transaction, rollback or end the transaction if needed. 
Also mange transaction have a retry logic, which means that if the transaction fails, it will be retried. Managed transactions are the most flexible way to run a Cypher query.

##### Implicit transactions 

Implicit auto commit queries are the simplest way to run a Cypher query since they won't be automatically retried as with writeTransaction and readTransaction. 
With implicit auto commit transactions, you don't have the same control of transaction as with manged explicit transactions. 

Here is the example of implicit transaction:
```java
public void createNode() {
    try (Session session = driver.session(SessionConfig.forDatabase("memgraph"))) {
        session.run("CREATE (n:Technology {name:'Memgraph'})");
    }
}
```

As you can see in this case you can run a simple query without any transaction management. This simplifys the experience but you lose some flexibility when running the queries. 
Since explicit transaction are multi-statement transactions, creating an index, constraints, auth config queries are not possible in multi-line transactions. Hence, you need to use implicit transactions for those queries.

#### Asynchronous transaction managment

##### Session management

Asynchronous sessions provide a API to work with futures. This allows client applications to work within asynchronous code bases. Asynchronous sessions are not thread safe, so you should create a new session for each thread.
Session lifetime begins with session construction, session is typicaly closed automatically when all results are consumed. 

The session is opened with the following code snippet: 

```java
 var session = driver.session(AsyncSession.class);
```

Via async session API you can use following transaction management methods:

 - `writeTransactionAsync` - executes a manged transaction workload in write access mode with retry logic.
 - `readTransactionAsync` - executes a managed transaction workload in read access mode with retry logic.
 - `runAsync` - executes a implicit auto-commit transaction and returns result.


##### Managed transactions 

Let's take a look into the basic example if you want to read data from the database via Async session API:

```java
public CompletionStage<ResultSummary> readNodesAsync() {
    String query = "MATCH (n:Technology {name: 'Memgraph'}) RETURN n;";
    var session = driver.session(AsyncSession.class);

    return session.executeReadAsync(tx -> tx.runAsync(query)
            .thenCompose(cursor -> cursor.forEachAsync(record ->
                    // asynchronously print every record
                    System.out.println(record.get(0).asString()))));

}
```


##### Implicit auto-commit asynchronous transactions

Implicit auto commit queries are the simplest way to run a Cypher query since they won't be automatically retried as with writeTransactionAsync and readTransactionAsync.

Here is the example of implicit transaction:

```java
public CompletionStage<ResultSummary> createNodeAsync() {
    String query = "CREATE (n:Technology {name:'Memgraph'})";
    var session = driver.session(AsyncSession.class);

    return session.runAsync(query)
            .thenCompose(ResultCursor::consumeAsync)
            .whenComplete((resultSummary, error) -> session.closeAsync());
}
```
