import { Steps } from "nextra/components";
import { Callout } from "nextra/components";

# Python client library guide

## Quickstart

The Python quick start guide will guide you through your first steps when connecting to Memgraph.
If there are any questions left unaswered and you are stuck, [join our community](https://www.discord.gg/memgraph) on Discord and ask away!

Here are the steps to create your first Python script which connects to a running database instance and visualizes your data:

<Steps>
### Install Python client library

First, you need to install the [Python client library](https://pypi.org/project/neo4j/) which requires Python >= 3.7, and can be installed with `pip`.

```
pip install neo4j
```

### Run Memgraph

The easiest way to start Memgraph is by running Memgraph Platform Docker image which includes Memgraph database, graph algorithms library (MAGE) and visual user interface (Memgraph Lab).

```
docker run -it -p 7687:7687 -p 7444:7444 -p 3000:3000 memgraph/memgraph-platform
```

After running the above command you will have a running Memgraph instance on `localhost:7687`. You can communicate with the database via Bolt protocol using Cypher queries.
To do that, use the command-line tool (mgconsole), Memgraph Lab on `localhost:3000` or a client library.

### Create Python script

To connect to a running Memgraph instance with the Python client library, create and save a Python script `quick-start.py` with the following content:

```python
from neo4j import GraphDatabase

# Define correct URI and AUTH arguments (no AUTH by default)
URI = "bolt://localhost:7687"
AUTH = ("", "")

with GraphDatabase.driver(URI, auth=AUTH) as driver:
    # Check the connection
    driver.verify_connectivity()

    # Create a user in the database
    records, summary, keys = driver.execute_query(
        "CREATE (u:User {name: $name, password: $password}) RETURN u.name AS name;",
        name="John",
        password="pass",
        database_="memgraph",
    )

    # Get the result
    for record in records:
        print(record["name"])

    # Print the query counters
    print(summary.counters)

    # Find a user John in the database
    records, summary, keys = driver.execute_query(
        "MATCH (u:User {name: $name}) RETURN u.name AS name",
        name="John",
        database_="memgraph",
    )

    # Get the result
    for record in records:
        print(record["name"])

    # Print the query
    print(summary.query)
```

### Run Python script

To test out the connection, run the Python script in your terminal:

```
python3 quick-start.py
```

Output:

```
John
{'labels_added': 1, 'labels_removed': 0, 'nodes_created': 1, 'nodes_deleted': 0, 'properties_set': 0, 'relationships_created': 0, 'relationships_deleted': 0}
John
MATCH (u:User {name: $name}) RETURN u.name AS name
```

### Visualize data

If you want to visualize what you created in the database with the `quick-start.py` script, head over to `localhost:3000` and run `MATCH (n) RETURN n;` at the Query Execution tab.
That query will visualize the created node and by clicking on it you can explore its properties.

![python-quick-start](/pages/client-libraries/new-python/python-quick-start.png)

To learn more about how to configure the database connection and how to run different kinds of transactions, read the [Python library usage](#python-library-usage) section. Happy coding!

</Steps>

## Python library usage

### Unencrypted database connection (default)

By default, the encryption setting is off, so the connection to the database is unencrypted.
To connect to Memgraph, create a driver object with the appropriate URI and AUTH arguments.
If you're running Memgraph locally, URI looks something like `bolt://localhost:7687`, and if you are running Memgraph on a remote server, replace `localhost` with the appropriate IP address.
If you ran Memgraph on port different than 7687, don't forget to update that in the URI too. By default, you can set username and password in the AUTH argument as empty strings. But, if you [created a user](/configuration/security#creating-users) in Memgraph, make sure to provide the correct connection details.

To verify the connection (credentials and versions) you can run the `verify_connectivity()` procedure on the driver object. Be aware that the connection verification can raise a number of different exceptions.

#### Connect without authentication

Here is an example of how to connect to Memgraph, that is running locally on port 7687, with the Python client library **without authentication** and how to get node count from the database:

```python
from neo4j import GraphDatabase

URI = "bolt://localhost:7687"
AUTH = ("", "")

with GraphDatabase.driver(URI, auth=AUTH) as driver:
    driver.verify_connectivity()

    # Count the number of nodes in the database
    records, summary, keys = driver.execute_query(
        "MATCH (n) RETURN count(n) AS num_of_nodes;"
    )

    # Get the result
    for record in records:
        print(record["num_of_nodes"])
```

#### Connect with authentication

If you [created a user](/configuration/security#creating-users) in Memgraph, then you need to provide the correct username and password when defining AUTH argument to connect to the database.
Let's say you already created a user with username `user` and password `pass`. Here is an example of how to connect to Memgraph, that is run locally on port 7687, with the Python client library **with authentication** and how to get node count from the database:

```python
from neo4j import GraphDatabase

URI = "bolt://localhost:7687"
AUTH = ("user", "pass")

with GraphDatabase.driver(URI, auth=AUTH) as driver:
    driver.verify_connectivity()

    # Count the number of nodes in the database
    records, summary, keys = driver.execute_query(
        "MATCH (n) RETURN count(n) AS num_of_nodes;", database_="memgraph"
    )

    # Get the result
    for record in records:
        print(record["num_of_nodes"])
```

<Callout type="info">

Note for Docker users

If the program fails to connect to a Memgraph instance that was started with
Docker, you may need to use a different IP address (not the default `localhost`
/ `127.0.0.1` ) to connect to the instance.

You can find the **`CONTAINER_ID`** with `docker ps` and use it in the following
command to retrieve the address:

```
docker inspect -f '{{range.NetworkSettings.Networks}}{{.IPAddress}}{{end}}' CONTAINER_ID
```

</Callout>

### Encrypted database connection with self-signed certificate

By using `bolt+ssc` you get encrypted connection with self-signed certificate. The example of such connection is when you want to **connect to Memgraph Cloud**.
When creating a project on Memgraph Cloud, you have a username and you create a password. After the project is started, Memgraph has assigned host address.
Copy those values and paste them in the `<MEMGRAPH_HOST_ADDRESS>`, `<MEMGRAPH_USERNAME>` and `<MEMGRAPH_PASSWORD>` fields in the code snippet below to connect successfully to the database.

```python
from neo4j import GraphDatabase

URI = "bolt+ssc://<MEMGRAPH_HOST_ADDRESS>"
AUTH = (<MEMGRAPH_USERNAME>, <MEMGRAPH_PASSWORD>)


with GraphDatabase.driver(URI, auth=AUTH) as driver:
    driver.verify_connectivity()

    # Count the number of nodes in the database
    records, summary, keys = driver.execute_query(
        "CREATE (u:User {name: $name, password: $password}) RETURN u.name AS name",
        name="John",
        password="pass",
        database_="memgraph",
    )

    # Get the result
    for record in records:
        print(record["name"])
```

### Query the database

#### Automatic transaction

To query the database, run the `execute_query()` procedure on the driver object with the Cypher query argument, along with its parameters and database name.
A good practice is to always provide a database name, to avoid extra request to the server and in that way, improve performance and to provide parameters to protect your queries from Cypher injections.
Since v2.10, Memgraph added the [multi-tenant support](/configuration/multi-tenancy) in the Enterprise Edition to manage multiple isolated databases within a single instance.
Make sure you provide the correct database name if you're working with more than one tenant.

The `execute_query()` procedure automatically creates a transaction in which you can include multiple Cypher statements in a single query. If a transaction fails, it automatically retries to run the transaction.

Bolt protocol specifies additional data that can be sent along with the requested results. Such data is called [metadata](/configuration/metadata) and can be divided into two groups: query statistics and notifications.
From the query statistics metadata we can get query counters that tell us which changes the **write query** triggered on the server.

```python
with GraphDatabase.driver(URI, auth=AUTH) as driver:
    # Create a user in the database
    records, summary, keys = driver.execute_query(
        "CREATE (u:User {name: $name, password: $password}) RETURN u.name AS name",
        name="John",
        password="pass",
        database_="memgraph",
    )

    # Get the result
    for record in records:
        print(record["name"])

    # Print the query counters
    print(summary.counters)
```

**Read queries** can be run in the same way. From their results, you won't get query counters, because the read queries are not making any change on the server.
Still, you can read the other parts of the summary, such as query that was run.

```python
with GraphDatabase.driver(URI, auth=AUTH) as driver:
    # Find a user John in the database
    records, summary, keys = driver.execute_query(
        "MATCH (u:User {name: $name}) RETURN u.name AS name",
        name="John",
        database_="memgraph",
    )

    # Get the result
    for record in records:
        print(record["name"])

    # Print the query
    print(summary.query)
```

On **update** and **delete queries** it is again useful to get the query counters to be sure how your change affected the database.

<Callout type="warning">

Error with multicommand transactions

`Index manipulation not allowed in multicommand transactions` is a kind of error you might experience. To fix that, use [implicit (or auto-commit) transactions](#implicit-transactions) instead.
That is the simplest way to run a Cypher query because implicit transactions won't be automatically retried as with `execute_query()` procedure or managed transactions.
To create a label-property index on `:User(name)`, run the following code:

```python
with GraphDatabase.driver(URI, auth=AUTH).session(database="memgraph") as session:
    session.run("CREATE INDEX ON :User(name);")
```

</Callout>

#### Manual transaction

With the `execute_query()` procedure you don't have a full control over the transaction lifecycle because it creates a transaction which can only be committed or rolled back on failure.
If you are a more advanced user who wants to have more control over the query execution, then you should use managed transactions to run your queries.

To run a transaction, you first need to create a **session**:

```python
my_session = driver.session(database="memgraph")
# do something with the session
my_session.close()
```

Don't forget to close the session after usage with `session.close()` or use `with` statement in Python which will automatically close a session, like in the following code snippet:

```python
with driver.session(database="memgraph") as session:
    # do something with the session

# session is automatically closed
```

Sessions are not thread safe, so make sure that each thread creates its own sessions. On the other hand, the main driver object can be shared across threads.
One transaction can contain multiple queries and they will either all be executed or none of them. This means that you don't have to worry about rolling back the part of the changes that got executed in that transaction and finding the ones that didn't.
Having more than one query in a transaction is useful when those queries work on a similar database task, usually creating graph database objects.

With sessions, you can run:

- [Manged transactions](#managed-transactions) - to run multiple queries with automatic retries without the possibility to roll back a query within a transaction.
- [Explicit transactions](#explicit-transactions) - to get full control over transactions by explicitely controlling the end of transaction that won't be automatically retried.
- [Implicit transactions](#implicit-transactions) - the simplest way to run a Cypher query that won't be automatically retried.

##### Managed transactions

To create a managed transaction, use `Session.execute_read()` procedure for read queries and `Session.execute_write()` procedure for write queries.

```python
def match_user(tx, name):
    result = tx.run(
        """
        MATCH (u:User) WHERE startsWith(u.name, $user_name)
        RETURN u.name as name
        """,
        user_name=name,
    )
    # process the result
    return list(result)


with GraphDatabase.driver(URI, auth=AUTH) as driver:
    with driver.session(database="memgraph") as session:
        people = session.execute_read(
            # transaction function callback
            match_user,
            "John",
        )
        for person in people:
            # get the result record as dict (key: value)
            print(person.data())
```

In case of exception being raised, the **transaction will be automatically rolled back**. If there is a return statement within transaction function, the transaction will be comitted.
In some cases, if a transaction fails, it is **automatically** being **retried**. That means that you can't be sure how many times a transaction function will be executed so you have to be careful that it produces the same effect when run multiple times.
Regardless of that, the queries inside the transaction function will always run only once. Session can contain multiple transactions but ony one transaction is active at any given time within session.
To maintain multiple concurrent transactions, use [multiple concurrent sessions](#concurrent-transactions).

##### Explicit transactions

With explicit transactions you can get the **full control over transactions**. To begin a transaction, run `Session.begin_transaction()` procedure and to run a transaction use `Transaction.run()` procedure.
Explicit transaction offers the possibility of explicitely controlling the end of transaction with `Transaction.commit()`, `Transaction.rollback()` or `Transaction.close()` methods, depending on what you need.

Use explicit transaction if you need to **distribute Cypher execution across multiple functions for the same transaction** or if you need to **run multiple queries within a single transactions without automatic retries**.

Here is an example of how to explicitly control the transaction of changing account balances based on some token transfer:

```python
def create_users(driver, sender, receiver):
    # Run multiple statements in a single query with execute_query() - not explicit transaction
    # If there is a failure, it will be rolled back
    summary = driver.execute_query(
        """
            CREATE (:User {id: $sender_id, name: $sender_name, account_balance: $sender_account_balance})
            CREATE (:User {id: $receiver_id, name: $receiver_name, account_balance: $receiver_account_balance})
        """,
        sender_id=sender["id"],
        sender_name=sender["name"],
        sender_account_balance=sender["account_balance"],
        receiver_id=receiver["id"],
        receiver_name=receiver["name"],
        receiver_account_balance=receiver["account_balance"],
    ).summary

    print(
        "Created {nodes_created} nodes.".format(
            nodes_created=summary.counters.nodes_created
        )
    )


def transfer_tokens(driver, sender_id, receiver_id, num_of_tokens):
    with driver.session(database="memgraph") as session:
        tx = session.begin_transaction()

        try:
            if not is_enough_token(tx, sender_id, num_of_tokens):
                print("Not enough tokens in the account balance.")
                return
            try:
                decrease_sender_balance(tx, sender_id, num_of_tokens)
                increase_receiver_balance(tx, receiver_id, num_of_tokens)
                tx.commit()  # both should be committed or none
            except Exception as e:
                raise e  # if exception happened roll back both
        finally:
            tx.close()  # rolls back if not yet committed


def is_enough_token(tx, user_id, num_of_tokens):
    query = """
        MATCH (u:User {id: $id})
        RETURN u.account_balance - $num_of_tokens >= 0 AS is_enough
    """
    result = tx.run(query, id=user_id, num_of_tokens=num_of_tokens)
    record = result.single(strict=True)
    return record["is_enough"]


def decrease_sender_balance(tx, sender_id, num_of_tokens):
    query = """
        MATCH (u:User {id: $id})
        SET u.account_balance = u.account_balance - $num_of_tokens
    """
    result = tx.run(query, id=sender_id, num_of_tokens=num_of_tokens)
    result.consume()


def increase_receiver_balance(tx, receiver_id, num_of_tokens):
    query = """
        MATCH (u:User {id: $id})
        SET u.account_balance = u.account_balance + $num_of_tokens
    """
    result = tx.run(query, id=receiver_id, num_of_tokens=num_of_tokens)
    result.consume()


def main():
    # If John has < 10 on his account balance, he won't have enough to send 10 tokens to Jenna
    sender = {"id": 1, "account_balance": 1000, "name": "John"}
    receiver = {"id": 2, "account_balance": 2000, "name": "Jenna"}

    with GraphDatabase.driver(URI, auth=AUTH) as driver:
        create_users(driver, sender, receiver)
        transfer_tokens(driver, 1, 2, 10)


if __name__ == "__main__":
    main()
```

In the above example, if you change John's account balance to a number less than 10, you will see the warning that he doesn't have enough tokens and the transfer won't happen (it will be rolled back).

##### Implicit transactions

Implicit or auto-commit transactions are the simplest way to run a Cypher query since they won't be automatically retried as with `execute_query()` procedure or managed transactions.
With implicit transactions, you don't have the same control of transaction as with explicit transactions, so they are mostly used for quick prototyping.

To run an implicit transaction, use `Session.run()` method:

```python
with GraphDatabase.driver(URI, auth=AUTH) as driver:
    with driver.session(database="memgraph") as session:
        session.run("CREATE (u:User {name: $name})", name="John")
```

The `Session.run()` method is most commonly used for `LOAD CSV` clause to prevent timeout errors due to the size of the transaction.

#### Concurrent transactions

AsyncGraphDatabase

## Where to next?
