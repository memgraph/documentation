import { Steps } from 'nextra/components'
import { Callout } from 'nextra/components'

# Python quick start

The Python quick start guide will guide you through your first steps when connecting to Memgraph.
If there are any questions left unaswered and you are stuck, [join our community](https://www.discord.gg/memgraph) on Discord and ask away!

Here are the steps to create your first Python script which connects to a running database instance and visualizes your data:

<Steps>
### Install Python client library

First, you need to install the [Python client library](https://pypi.org/project/neo4j/) which requires Python >= 3.7, and can be installed with `pip`. 

```
pip install neo4j
```

### Run Memgraph

The easiest way to start Memgraph is by running Memgraph Platform Docker image which includes Memgraph database, graph algorithms library (MAGE) and visual user interface (Memgraph Lab).

```
docker run -it -p 7687:7687 -p 7444:7444 -p 3000:3000 memgraph/memgraph-platform
```

After running the above command you will have a running Memgraph instance on `localhost:7687`. You can communicate with the database via Bolt protocol using Cypher queries. 
To do that, use the command-line tool (mgconsole), Memgraph Lab on `localhost:3000` or a client library.

 
### Create Python script

To connect to a running Memgraph instance with the Python client library, create and save a Python script `quick-start.py` with the following content:

```python
from neo4j import GraphDatabase

# Define correct URI and AUTH arguments (no AUTH by default)
URI = "bolt://localhost:7687"
AUTH = ("", "")

with GraphDatabase.driver(URI, auth=AUTH) as driver:
    # Check the connection
    driver.verify_connectivity()

    # Create a user in the database
    records, summary, keys = driver.execute_query(
        "CREATE (u:User {name: $name, password: $password}) RETURN u.name AS name;",
        name="John",
        password="pass",
        database_="memgraph",
    )

    # Get the result
    for record in records:
        print(record["name"])
    
    # Print the query counters
    print(summary.counters)

    # Find a user John in the database
    records, summary, keys = driver.execute_query(
        "MATCH (u:User {name: $name}) RETURN u.name AS name",
        name="John",
        database_="memgraph",
    )

    # Get the result
    for record in records:
        print(record["name"])
    
    # Print the query
    print(summary.query)
```

### Run Python script

To test out the connection, run the Python script in your terminal:

```
python3 quick-start.py
```

Output:
```
John
{'labels_added': 1, 'labels_removed': 0, 'nodes_created': 1, 'nodes_deleted': 0, 'properties_set': 0, 'relationships_created': 0, 'relationships_deleted': 0}
John
MATCH (u:User {name: $name}) RETURN u.name AS name
```

### Visualize data

If you want to visualize what you created in the database with the `quick-start.py` script, head over to `localhost:3000` and run `MATCH (n) RETURN n;` at the Query Execution tab. 
That query will visualize the created node and by clicking on it you can explore its properties. 

![python-quick-start](/pages/client-libraries/new-python/python-quick-start.png)

To learn more about how to configure the database connection and how to run different kinds of transactions, read the [Python library usage](#python-library-usage) section. Happy coding!

</Steps>


## Python library usage

### Unencrypted database connection (default)

By default, the encryption setting is off, so the connection to the database is unencrypted. 
To connect to Memgraph, create a driver object with the appropriate URI and AUTH arguments. 
If you're running Memgraph locally, URI looks something like `bolt://localhost:7687`, and if you are running Memgraph on a remote server, replace `localhost` with the appropriate IP address. 
If you ran Memgraph on port different than 7687, don't forget to update that in the URI too. By default, you can set username and password in the AUTH argument as empty strings. But, if you [created a user](/configuration/security#creating-users) in Memgraph, make sure to provide the correct connection details.

To verify the connection (credentials and versions) you can run the `verify_connectivity()` procedure on the driver object. Be aware that the connection verification can raise a number of different exceptions.


#### Connect without authentication
Here is an example of how to connect to Memgraph, that is running locally on port 7687, with the Python client library **without authentication** and how to get node count from the database: 

```python
from neo4j import GraphDatabase

URI = "bolt://localhost:7687"
AUTH = ("", "")

with GraphDatabase.driver(URI, auth=AUTH) as driver:
    driver.verify_connectivity()

    # Count the number of nodes in the database
    records, summary, keys = driver.execute_query(
        "MATCH (n) RETURN count(n) AS num_of_nodes;"
    )

    # Get the result
    for record in records:
        print(record["num_of_nodes"])
```

#### Connect with authentication

If you [created a user](/configuration/security#creating-users) in Memgraph, then you need to provide the correct username and password when defining AUTH argument to connect to the database.
Let's say you already created a user with username `user` and password `pass`. Here is an example of how to connect to Memgraph, that is run locally on port 7687, with the Python client library **with authentication** and how to get node count from the database: 

```python
from neo4j import GraphDatabase

URI = "bolt://localhost:7687"
AUTH = ("user", "pass")

with GraphDatabase.driver(URI, auth=AUTH) as driver:
    driver.verify_connectivity()

    # Count the number of nodes in the database
    records, summary, keys = driver.execute_query(
        "MATCH (n) RETURN count(n) AS num_of_nodes;", database_="memgraph"
    )

    # Get the result
    for record in records:
        print(record["num_of_nodes"])
```

<Callout type="info"> 

Note for Docker users

If the program fails to connect to a Memgraph instance that was started with
Docker, you may need to use a different IP address (not the default `localhost`
/ `127.0.0.1` ) to connect to the instance.

You can find the **`CONTAINER_ID`** with `docker ps` and use it in the following
command to retrieve the address:

```
docker inspect -f '{{range.NetworkSettings.Networks}}{{.IPAddress}}{{end}}' CONTAINER_ID
```

</Callout>

### Encrypted database connection with self-signed certificate

By using `bolt+ssc` you get encrypted connection with self-signed certificate. The example of such connection is when you want to **connect to Memgraph Cloud**.
When creating a project on Memgraph Cloud, you have a username and you create a password. After the project is started, Memgraph has assigned host address.
Copy those values and paste them in the `<MEMGRAPH_HOST_ADDRESS>`, `<MEMGRAPH_USERNAME>` and `<MEMGRAPH_PASSWORD>` fields in the code snippet below to connect successfully to the database.  

```python
from neo4j import GraphDatabase

URI = "bolt+ssc://<MEMGRAPH_HOST_ADDRESS>"
AUTH = (<MEMGRAPH_USERNAME>, <MEMGRAPH_PASSWORD>)


with GraphDatabase.driver(URI, auth=AUTH) as driver:
    driver.verify_connectivity()

    # Count the number of nodes in the database
    records, summary, keys = driver.execute_query(
        "CREATE (u:User {name: $name, password: $password}) RETURN u.name AS name",
        name="John",
        password="pass",
        database_="memgraph",
    )

    # Get the result
    for record in records:
        print(record["name"])
```

### Query the database

To query the database, run the `execute_query()` procedure on the driver object with the Cypher query argument, along with its parameters and database name. 
A good practice is to always provide a database name, to avoid extra request to the server and in that way, improve performance and to provide parameters to protect your queries from Cypher injections.
Since v2.10, Memgraph added the [multi-tenant support](/configuration/multi-tenancy) in the Enterprise Edition to manage multiple isolated databases within a single instance. 
Make sure you provide the correct database name if you're working with more than one tenant. 

The `execute_query()` procedure automatically creates a transaction in which you can include multiple Cypher statements in a single query.

Bolt protocol specifies additional data that can be sent along with the requested results. Such data is called [metadata](/configuration/metadata) and can be divided into two groups: query statistics and notifications.
From the query statistics metadata we can get query counters that tell us which changes the **write query** triggered on the server.

```python
with GraphDatabase.driver(URI, auth=AUTH) as driver:
    # Create a user in the database
    records, summary, keys = driver.execute_query(
        "CREATE (u:User {name: $name, password: $password}) RETURN u.name AS name",
        name="John",
        password="pass",
        database_="memgraph",
    )

    # Get the result
    for record in records:
        print(record["name"])
    
    # Print the query counters
    print(summary.counters)
```

**Read queries** can be run in the same way. From their results, you won't get query counters, because the read queries are not making any change on the server. 
Still, you can read the other parts of the summary, such as query that was run.

```python
with GraphDatabase.driver(URI, auth=AUTH) as driver:
    # Find a user John in the database
    records, summary, keys = driver.execute_query(
        "MATCH (u:User {name: $name}) RETURN u.name AS name",
        name="John",
        database_="memgraph",
    )

    # Get the result
    for record in records:
        print(record["name"])
    
    # Print the query
    print(summary.query)
```

On **update** and **delete queries** it is again useful to get the query counters to be sure how your change affected the database.

<Callout type="warning">

Error with multicommand transactions


`Index manipulation not allowed in multicommand transactions` is a kind of error you might experience. To fix that, use implicit (or auto-commit) transactions instead. 
That is the simplest way to run a Cypher query because implicit transactions won't be automatically retried as with `execute_query()` procedure or managed transactions. 
To create a label-property index on `:User(name)`, run the following code:
```python
with GraphDatabase.driver(URI, auth=AUTH).session(database="memgraph") as session:
    session.run("CREATE INDEX ON :User(name);")
```
</Callout>


#### Managed transactions

With the `execute_query()` procedure you don't have a full control over the transaction lifecycle because it creates a transaction which can only be committed or rolled back on failure.
If you are a more advanced user who wants to have more control over the query execution, then you should use managed transactions to run your queries.

To use managed transactions, you first need to create a session:

```python
my_session = driver.session(database="memgraph")
# do something with the session
my_session.close()
```

Don't forget to close the session after usage with `session.close()` or use `with` statement in Python which will automatically close a session, like in the following code snippet:

```python
with driver.session(database="memgraph") as session:
    # do something with the session

# session is automatically closed
```

Sessions are not thread safe, so make sure that each thread creates its own sessions. On the other hand, the main driver object can be shared across threads.
One transaction can contain multiple queries and they will either all be executed or none of them. This means that you don't have to worry about rolling back the part of the changes that got executed in that transaction and finding the ones that didn't.
Having more than one query in a transaction is useful when those queries work on a similar database task, usually creating graph database objects. 

To create a managed transaction, use `Session.execute_read()` procedure for read queries and `Session.execute_write()` procedure for write queries. 

```python
from neo4j import GraphDatabase

URI = "bolt://localhost:7687"
AUTH = ("", "")


def match_user(tx, name):
    result = tx.run(
        """ 
        MATCH (u:User) WHERE startsWith(u.name, $user_name)
        RETURN u.name as name
        """,
        user_name=name,
    )
    # process the result
    return list(result)  


with GraphDatabase.driver(URI, auth=AUTH) as driver:
    with driver.session(database="memgraph") as session:
        people = session.execute_read(
            # transaction function callback
            match_user,
            "John",
        )
        for person in people:
            # get the result record as dict (key: value)
            print(person.data())
```

In case of exception being raised, the transaction will be automatically rolled back. If there is a return statement within transaction function, the transaction will be comitted. 
In some cases, if a transaction fails, it is automatically being retried. That means that you can't be sure how many times a transaction function will be executed so you have to be careful that it produces the same effect when run multiple times. 
Regardless of that, the queries inside the transaction function will always run only once. Session can contain multiple transactions but ony one transaction is active at any given time within session. 
To maintain multiple concurrent transactions, use [multiple concurrent sessions](#concurrent-transactions).


#### Explicit transactions

begin session, run transaction, close transaction, close session
as opposed to managed transaction, it can be rolled back

#### Implicit transactions

give query to session and run it, close session
usage: importing large CSV files into the database with the LOAD CSV Cypher clause

#### Concurrent transactions

AsyncGraphDatabase
