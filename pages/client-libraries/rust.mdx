import { Callout } from 'nextra/components'
import { Steps } from 'nextra/components'


# Rust client guide 

Learn how to create a Rust application that connects to the Memgraph database and executes simple queries.

This guide is based on the Memgraph Rust driver [rsmgclient](https://github.com/memgraph/rsmgclient).

<Callout type="info">
Keep in mind that if you are already using [neo4rs](https://github.com/neo4j-labs/neo4rs), you can use Neo4j driver with Memgraph, since Memgraph is compatible with Neo4j drivers.
</Callout>

## Quickstart 

The following guide will demonstrate how to start Memgraph, connect to Memgraph, seed the database with data, run simple read and write queries. 

Prerequisite that are necessary and sould be installed in your local enviroment are following: 

 - [Rust programming language](https://www.rust-lang.org/tools/install)
 - [Docker](https://docs.docker.com/get-docker/) 

This won't be covered in this guide, but you can find more information on how to install them in the links above.

<Steps>
### Run Memgraph 

Start by running Memgraph in the background. The easiest way to install and run Memgraph is by using Docker. Start the container with the following command:


```bash
docker run -it -p 7687:7687 -p 7444:7444 -p 3000:3000 --name memgraph memgraph/memgraph-platform
```

This command above will start [Memgraph Platform](/getting-started/install-memgraph/docker#install-memgraph-platform), which includes,[Memgraph database](/getting-started/install-memgraph/docker#other-available-docker-images), [Memgraph Lab](/data-visualization#quick-start) and [Memgraph MAGE](/advanced-algorithms#quick-start). Memgraph uses Bolt protocol to communicate with the client using the exposed 7687 port. 
Memgraph Lab is a web application that can be used to visualize your data, it is available on port 3000, and port 7444 is used for the logs that are visible in the Memgraph Lab, so both port 3000 for LAB and 7444 for logs need to be open. If the Memgraph Platform is running properly, open a URL http://localhost:3000 in your browser and you should see the Memgraph Lab UI. 

For more information visit the getting started guide on [how to run Memgraph with Docker](/getting-started/install-memgraph/docker).

### Create a directory 

Next, create a directory for your project and positioning yourself in it:

```bash
mkdir hello-memgraph
cd hello-memgraph
```

### Create a new Rust project

If Rust is properly installed, you can create a new Rust project with the following command:

```bash
cargo new hello-memgraph
```

This will create a new directory called `hello-memgraph` with the following structure:

```bash
hello-memgraph
├── Cargo.toml
└── src
    └── main.rs
```

### Add rsmgclient dependency

To use the rsmgclient driver, you need to add it to the `Cargo.toml` file under the line `[dependencies]`:

```toml
rsmgclient = "2.0.1"
```

### Write a minimal working example 

Now, let's write a minimal working example that will connect to Memgraph and execute a simple queries:

```rust
use rsmgclient::{ConnectParams, Connection, Value, SSLMode, ConnectionStatus};
 
fn main() {

    // Connect to Memgraph 
    let connect_params = ConnectParams {
        host: Some(String::from("localhost")),
        port: 7687,
        sslmode: SSLMode::Disable,
        ..Default::default()
    };
    let mut connection = Connection::connect(&connect_params).unwrap();

    // Check if connection is established.
    let status = connection.status();
    
    if status != ConnectionStatus::Ready {
        println!("Connection failed with status: {:?}", status);
        return;
    } else {
        println!("Connection established with status: {:?}", status);
    }
       
    // Clear the graph.
    connection.execute_without_results("MATCH (n) DETACH DELETE n;").unwrap();
    if let Err(e) = connection.commit() {
        println!("Error: {}", e);
    }
    
    let indexes = vec![
        "CREATE INDEX ON :Developer(id);",
        "CREATE INDEX ON :Technology(id);",
        "CREATE INDEX ON :Developer(name);",
        "CREATE INDEX ON :Technology(name);",
    ];

    let developer_nodes = vec![
        "CREATE (n:Developer {id: 1, name:'Andy'});",
        "CREATE (n:Developer {id: 2, name:'John'});",
        "CREATE (n:Developer {id: 3, name:'Michael'});",
    ];

    let technology_nodes = vec![
        "CREATE (n:Technology {id: 1, name:'Memgraph', description: 'Fastest graph DB in the world!', createdAt: Date()})",
        "CREATE (n:Technology {id: 2, name:'Rust', description: 'Rust programming language ', createdAt: Date()})",
        "CREATE (n:Technology {id: 3, name:'Docker', description: 'Docker containerization engine', createdAt: Date()})",
        "CREATE (n:Technology {id: 4, name:'Kubernetes', description: 'Kubernetes container orchestration engine', createdAt: Date()})",
        "CREATE (n:Technology {id: 5, name:'Python', description: 'Python programming language', createdAt: Date()})",
    ];

    let relationships = vec![
        "MATCH (a:Developer {id: 1}),(b:Technology {id: 1}) CREATE (a)-[r:LOVES]->(b);",
        "MATCH (a:Developer {id: 2}),(b:Technology {id: 3}) CREATE (a)-[r:LOVES]->(b);",
        "MATCH (a:Developer {id: 3}),(b:Technology {id: 1}) CREATE (a)-[r:LOVES]->(b);",
        "MATCH (a:Developer {id: 1}),(b:Technology {id: 5}) CREATE (a)-[r:LOVES]->(b);",
        "MATCH (a:Developer {id: 2}),(b:Technology {id: 2}) CREATE (a)-[r:LOVES]->(b);",
        "MATCH (a:Developer {id: 3}),(b:Technology {id: 4}) CREATE (a)-[r:LOVES]->(b);",
    ];

    for index in indexes {
        connection.execute_without_results(index).unwrap();
    }
    if let Err(e) = connection.commit() {
        println!("Error: {}", e);
    }

    for developer_node in developer_nodes {
        connection.execute_without_results(developer_node).unwrap();
    }
    if let Err(e) = connection.commit() {
        println!("Error: {}", e);
    }

    for technology_node in technology_nodes {
        connection.execute_without_results(technology_node).unwrap();
    }
    if let Err(e) = connection.commit() {
        println!("Error: {}", e);
    }

    for relationship in relationships {
        connection.execute_without_results(relationship).unwrap();
    }
    if let Err(e) = connection.commit() {
        println!("Error: {}", e);
    }

    // Fetch the graph.
    let columns = connection.execute("MATCH (n)-[r]->(m) RETURN n, r, m;", None);
    println!("Columns: {}", columns.unwrap().join(", "));
    
    while let Ok(result) = connection.fetchall() {
        for record in result {
            for value in record.values {
                match value {
                    Value::Node(node) => println!("Node: {}", node),
                    Value::Relationship(edge) => println!("Edge: {}", edge),
                    value => println!("Value: {}", value),
                }
            }
        }
     
        println!();
    }
    // Close the connection.
    connection.close();

}
```

### Build the project 

To build the project, run the following command within the project directory:

```bash
cargo build
```

### Run the project

To run the project, run the following command within the project directory:

```bash
cargo run
```

If everything is working properly, you should see the following output:

```text
Connection established with status: Ready
Columns: n, r, m
Node: (:Developer {'id': 1, 'name': 'Andy'})
Edge: [:LOVES {}]
Node: (:Technology {'createdAt': '2023-09-05', 'description': 'Fastest graph DB in the world!', 'id': 1, 'name': 'Memgraph'})
Node: (:Developer {'id': 3, 'name': 'Michael'})
Edge: [:LOVES {}]
Node: (:Technology {'createdAt': '2023-09-05', 'description': 'Fastest graph DB in the world!', 'id': 1, 'name': 'Memgraph'})
Node: (:Developer {'id': 2, 'name': 'John'})
Edge: [:LOVES {}]
Node: (:Technology {'createdAt': '2023-09-05', 'description': 'Rust programming language ', 'id': 2, 'name': 'Rust'})
Node: (:Developer {'id': 2, 'name': 'John'})
Edge: [:LOVES {}]
Node: (:Technology {'createdAt': '2023-09-05', 'description': 'Docker containerization engine', 'id': 3, 'name': 'Docker'})
Node: (:Developer {'id': 3, 'name': 'Michael'})
Edge: [:LOVES {}]
Node: (:Technology {'createdAt': '2023-09-05', 'description': 'Kubernetes container orchestration engine', 'id': 4, 'name': 'Kubernetes'})
Node: (:Developer {'id': 1, 'name': 'Andy'})
Edge: [:LOVES {}]
Node: (:Technology {'createdAt': '2023-09-05', 'description': 'Python programming language', 'id': 5, 'name': 'Python'})
```

### Visualize the data 

To visualize objects created in the database with the `main.rs` script, head over to [http://localhost:3000/](http://localhost:3000/) and run `MATCH path=(n)-[p]-(m) RETURN path` in the *Query Execution* tab. 
That query will visualize the created nodes and relationships. By clicking on a node or relationship, you can explore different properties.

![rust-quick-start](/pages/client-libraries/rust/rust-quick-start.png)


### Next steps 

This makes a good starting point for Rust application. For more information on how to use the Rust driver, 
continue reading the guide under [Rust client API usage and examples](#rust-client-api-usage-and-examples). 

</Steps>

## Rust client API usage and examples

After a brief [Quickstart guide](#quickstart), this section will go into more detail on how to use the Rust driver API, explain code snippets, and provide more examples. Feel free to skip to the section that interests you the most.

### Database connection 

Once the database is running, and driver is installed or available in Rust, you should be able to connect to the database with one of two ways:

- [Connect without authentication (default)](#connect-without-authentication-default)
- [Connect with authentication](#connect-with-authentication)

#### Connect without authentication (default)

By default, the Memgraph database is running without authentication, which means that you can connect to the database without providing any credentials (username and password).
To connect to Memgraph, create a driver object with the appropriate host, port and credentials arguments. If you're running Memgraph locally, the host should be `localhost`, and port `7687` by default. If you are running Memgraph on a remote server, 
replace `localhost` with the appropriate IP address, or if you ran Memgraph on port different than 7687, do not forget to update change the port. 


To connect the Rust driver to the Memgraph database, use the following code snippet: 

```rust

use rsmgclient::{ConnectParams, Connection, Value, SSLMode, ConnectionStatus};
 
fn main() {

    // Connect to Memgraph 
    let connect_params = ConnectParams {
        host: Some(String::from("localhost")),
        port: 7687,
        sslmode: SSLMode::Disable,
        ..Default::default()
    };
    let mut connection = Connection::connect(&connect_params).unwrap();

    // Check if connection is established.
    let status = connection.status();
    
    if status != ConnectionStatus::Ready {
        println!("Connection failed with status: {:?}", status);
        return;
    } else {
        println!("Connection established with status: {:?}", status);
    }

``` 

All default connection parameters can be seen in the [rsmgclient repository](https://github.com/memgraph/rsmgclient/blob/master/src/connection/mod.rs#L84). The default values for the username and password are `None`, which means that you can connect to the database without providing any credentials.


#### Connect with authentification

In order to set up authentication in Memgraph, you need to set up a user that has `username` and `password`. In Memgraph you can set a username and password by executing the following query: 

```Cypher
CREATE USER `memgraph` IDENTIFIED BY 'memgraph';
```

Then, you can connect to the database with the following snippet:

```rust {9-10}
use rsmgclient::{ConnectParams, Connection, Value, SSLMode, ConnectionStatus};
 
fn main() {

    // Connect to Memgraph 
    let connect_params = ConnectParams {
        host: Some(String::from("localhost")),
        port: 7687,
        username: Some(String::from("memgraph")),
        password: Some(String::from("memgraph")),
        sslmode: SSLMode::Disable,
        ..Default::default()
    };
    let mut connection = Connection::connect(&connect_params).unwrap();

    // Check if connection is established.
    let status = connection.status();

    if status != ConnectionStatus::Ready {
        println!("Connection failed with status: {:?}", status);
        return;
    } else {
        println!("Connection established with status: {:?}", status);
    }
```
If you receive the following error: 

```
thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: MgError { message: "Authentication failure" }'
```

The error indicates that you have probably enabled authentication in Memgraph, but are trying to connect without authentication. For more details on how to set authentication further, visit the [Memgraph authentication guide](/configuration/security/#creating-user).

#### Rust client connection lifecycle managment 

Each connection object is a separate session with the database. The connection object is responsible for executing queries and fetching results. Memgraph will automatically close the connection if the client does not use it for a certain period of time.
Make sure that you close the connection when you are done with it, and open a new connection when you need to execute a new query. 

### Query the database 

After connecting your driver to Memgraph. you can start running queries. 

#### Run a create query

The folowing example will create a node in the database: 

```rust
    let _create_node = "CREATE (n:Technology {name: 'Memgraph'}) RETURN n";
    let _columns = connection.execute(_create_node, None);
    while let Ok(result) =  connection.fetchall() {
        for record in result {
            for value in record.values {
                match value {
                    Value::Node(node) => println!("Node: {}", node),
                    value => println!("Value: {}", value),
                }
            }
        }
    }
    
    if let Err(e) = connection.commit() {
        println!("Error: {}", e);
    }
```

Method executed takes the following arguments:

- `query` - The query that will be executed.
- `params` - The parameters that will be passed to the query.


If you do not need to fetch the results, you can use the `execute_without_results` method, then the code becomes simpler:
 
```rust
let _create_node = "CREATE (n:Technology {name: 'Memgraph'}) RETURN n";
connection.execute_without_results(_create_node).unwrap();
if let Err(e) = connection.commit() {
    println!("Error: {}", e);
}
```
`execute_without_results` method takes just the query as an argument.

#### Run a read query   

The following query will read data from the database: 

```rust
    let _read_node = "MATCH (n:Technology {name: 'Memgraph'}) RETURN n";
    let _columns = connection.execute(_read_node, None);
    while let Ok(result) =  connection.fetchall() {
        for record in result {
            for value in record.values {
                match value {
                    Value::Node(node) => println!("Node: {}", node),
                    value => println!("Value: {}", value),
                }
            }
        }
    }
    if let Err(e) = connection.commit() {
        println!("Error: {}", e);
    }
```

In this example, the match statement is used to distinguish between different types of values that can be returned from the database. In this case the query will return a node, so the rest of logic could be based on that information. 


#### Running a queries with property map 

If you want to pass a property map to the query, you can do it like this:

```rust
    let _create_node = "CREATE (n:Technology {name: $name, description: $description}) RETURN n";
    let mut params = HashMap::new();
    params.insert("name".to_string(), QueryParam::String("Memgraph".to_string()));
    params.insert("description".to_string(), QueryParam::String("Fastest graph DB in the world!".to_string()));
    let _columns = connection.execute(_create_node, Some(&params));
    while let Ok(result) =  connection.fetchall() {
        for record in result {
            for value in record.values {
                match value {
                    Value::Node(node) => println!("Node: {}", node),
                    value => println!("Value: {}", value),
                }
            }
        }
    }
    if let Err(e) = connection.commit() {
        println!("Error: {}", e);
    }
```

Using this approach, the queries will not contain hard-coded values, they can be more dynamic.


### Process the results

