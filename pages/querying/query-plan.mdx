---
title: Query plan
description: Understand how to read and interpret the query plan
---

import { Callout } from "nextra/components";


# Query plan

Cypher is a declarative language. This means that you specify what you want to retrieve, but not how to retrieve it. This 
means the Memgraph Query engine is responsible for figuring out the best way to execute the Cypher query.

In order to do this, each Cypher query is translated into a query plan.
Query plans are a way to understand how the Memgraph query engine will execute 
a query. Query engine can do a lot of optimizations, but also it can make mistakes. Hence, 
the query plan is a useful tool to understand query execution and to identify potential performance issues.

## Query plan structure

The users just intreact with the Cyher to tune the Query plan structure. Query plan is a internal tree-like data 
structure describing a pipeline of operations  which will be performed on the database in order to yield the results for a given query. 
Every node within a plan is known as a *logical operator* and describes a particular operation.

Because a plan represents a pipeline, the logical operators are iteratively
executed as data passes from one logical operator to the other. Every logical
operator *pulls* data from the logical operator(s) preceding it, processes it
and passes it onto the logical operator next in the pipeline for further
processing.

Query plan can be obtained by prefixing the query with [`EXPLAIN`](./clauses/explain.md) or [`PROFILE`](./clauses/profile.md) clauses.

Here is the basic example of a produced query plan for the simple query:

```cypher
EXPLAIN MATCH (n) RETURN n;
```
```
+----------------+
| QUERY PLAN     |
+----------------+
|  * Produce {n} |
|  * ScanAll (n) |
|  * Once        |
+----------------+
```
<Callout type="info">
Query plan should be read from the bottom to the top.
</Callout>

The output of the query using the `EXPLAIN` clause is a representation of the produced plan. Every
logical operator within the plan starts with an asterisk character (`*`) and is
followed by its name (and sometimes additional information). The execution of
the query proceeds iteratively (generating one entry of the result set at a
time), with data flowing from the bottom-most logical operator(s) (the start of
the pipeline) to the top-most logical operator(s) (the end of the pipeline).

In the example above, the resulting plan is a pipeline of 3 logical operators.
`Once` is the identity logical operator which does nothing and is always found
at the start of the pipeline; `ScanAll` is a logical operator which iteratively
produces all of the nodes in the graph; and `Produce` is a logical operator
which takes data produced by another logical operator and produces data for the
query's result set.

A simple example showcasing the fully general tree structure of the plan could
be:

```cypher
EXPLAIN MERGE (n) RETURN n;
```

```
+------------------+
| QUERY PLAN       |
+------------------+
|  * Produce {n}   |
|  * Accumulate    |
|  * Merge         |
|  |\ On Match     |
|  | * ScanAll (n) |
|  | * Once        |
|  |\ On Create    |
|  | * CreateNode  |
|  | * Once        |
|  * Once          |
+------------------+
```

Starting from the bottom and skiping `Once`, the `Merge` logical operator (constructed as a result of the `MERGE` construct)
can take input from two operators, `On Match` or `On Create`. The `On Match` and `On Create` branches are
"pulled from" only if a match was found or if a new vertex has to be created. Each branch again has its own pipeline of logical operators, that starts with `Once`,
and it is being read from the bottom to the top.

The more complicated example showcases the tree-like structure of the plan with `Merge` would be this: 


```cypher
EXPLAIN MERGE (p:Person {name: 'Angela'})
ON MATCH SET p.found = TRUE
ON CREATE SET p.notFound = TRUE
RETURN p.name, p.notFound, p.found;
```

```
+------------------------------------------+
| QUERY PLAN                               |
+------------------------------------------+
|  * Produce {p.name, p.notFound, p.found} |
|  * Accumulate                            |
|  * Merge                                 |
|  |\ On Match                             |
|  | * SetProperty                         |
|  | * Filter (p :Person), {p.name}        |
|  | * ScanAll (p)                         |
|  | * Once                                |
|  |\ On Create                            |
|  | * SetProperty                         |
|  | * CreateNode                          |
|  | * Once                                |
|  * Once                                  |
+------------------------------------------+
```


In this examples each of the branches of the `Merge` operator has its own pipeline of logical operators.
The `On Match` branch has a `Filter` operator, which filters the nodes based on the label and property, 
and `SetProperty` operator, which sets the property on the node. The `On Create` branch has a `CreateNode` operator,
which creates a new node, and `SetProperty` operator, which sets the property on the node.



## Query plan operators 

Each of the mentioned operators in the query plan represents a particular operation that will be performed on the data. 

The following table list all the operators currently supported by Memgraph:

| Operator                      | Description                                                                                                                |
| ----------------------------- | -------------------------------------------------------------------------------------------------------------------------- |
| `Accumulate`                    | Accumulates the input it received.                                                                                       |
| `Aggregate`                     | Aggregates the input it received.                                                                                        |
| `Apply`                         | Joins the returned symbols from two branches of execution.                                                               |
| `CallProcedure`                 | Calls a procedure.                                                                                                       |
| `Cartesian`                     | Applies the Cartesian product (the set of all possible ordered combinations consisting of one member from each of those sets) on the input it received. |
| `ConstructNamedPath`            | Creates a path.                                                                                                          |
| `CreateNode`                    | Creates a node.                                                                                                          |
| `CreateExpand`                  | Creates edges and  new nodes to connect with existing nodes.                                                             |
| `Delete`                        | Deletes nodes and edges.                                                                                                 |
| `EdgeUniquenessFilter`          | Filters unique edges.                                                                                                    |
| `EmptyResult`                   | Discards results from the previous operator.                                                                             |
| `EvaluatePatternFilter`         | Part of the filter operator that contains a sub-branch which yields either true or false.                                |
| `Expand`                        | Expands the node by finding the node's relationships.                                                                    |
| `ExpandVariable`                | Performs a node expansion of a variable number of relationships                                                          |
| `Filter`                        | Filters the input it received.                                                                                           |
| `Foreach`                       | Iterates over a list and applies one or more update clauses.                                                             |
| `HashJoin`                      | Performs a hash join of the input from its two input branches.                                                           |
| `IndexedJoin`                   | Performs an indexed join of the input from its two input branches.                                                       |
| `Limit`                         | Limits certain rows from the pull chain.                                                                                 |
| `LoadCsv`                       | Loads CSV file in order to import files into the database.                                                               |
| `Merge`                         | Applies merge on the input it received.                                                                                  |
| `Once`                          | Forms the beginning of an operator chain with "only once" semantics. The operator will return false on subsequent pulls. |
| `Optional`                      | Performs optional matching.                                                                                              |
| `OrderBy`                       | Orders the input it received.                                                                                            |
| `Produce`                       | Produces results.                                                                                                        |
| `RemoveLabels`                  | Removes a variable number of node labels.                                                                                |
| `RemoveProperty`                | Removes a node or relationship property.                                                                                 |
| `ScanAll`                       | Produces all nodes in the database.                                                                                      |
| `ScanAllById`                   | Produces nodes with a certain index.                                                                                     |
| `ScanAllByLabel`                | Produces nodes with a certain label.                                                                                     |
| `ScanAllByLabelProperty`        | Produces nodes with a certain label and property.                                                                        |
| `ScanAllByLabelPropertyRange`   | Produces nodes with a certain label and property value within the given range (both inclusive and exclusive).            |
| `ScanAllByLabelPropertyValue`   | Produces nodes with a certain label and property value.                                                                  |
| `SetLabels`                     | Sets node labels of variable length.                                                                                     |
| `SetProperty`                   | Sets a node or relationship property.                                                                                    |
| `SetProperties`                 | Sets a list of node or relationship properties.                                                                          |
| `Skip`                          | Skips certain rows from the pull chain.                                                                                  |
| `Unwind`                        | Unwinds an expression to multiple records.                                                                               |
| `Distinct`                      | Applies a distinct filter on the input it received.                                                                      |

Some of the operators are always present and bolierplate operators, such as `Once` and `Produce`. 

`Once` is the operator that represent the first operator in the query plan and it is always present. It is used to signal the start of the query plan and to 
signal the start of the operator chain in second branch. 

`Produce` is the operator that represent the last operator in the query plan and it is always present. It is used to signal the end of the query plan and connected to usage
of the `RETURN` clause in the query, if there is nothing to return the `EmptyResult` will be part of the qury plan.  Here is an example of the query plan with `Once` and `Produce` operators:

```cypher
EXPLAIN RETURN 0;
```

```
+------------------+
| QUERY PLAN       |
+------------------+
| " * Produce {0}" |
| " * Once"        |
+------------------+
```

`ScanAll` is the operator that represents the operator that produces all nodes in the database. This means that it will touch every node in the graph and it will 
pass that data to the next operator in the query plan. This operator is used when there is no filtering on the nodes, and it an expensive operator to use on large graphs.
For details on how to optimize the query plan execution, read the [performance guide](./performance-optimization.md).

```cypher
EXPLAIN MATCH (n) RETURN n;
```
```
+----------------+
| QUERY PLAN     |
+----------------+
|  * Produce {n} |
|  * ScanAll (n) |
|  * Once        |
+----------------+
```

`Filter` is the operator that filters the input it received. This operator is used when there is a filtering on the nodes and relationship properties or labels. 
Typically, the `MATCH` clause arguments are used to filter the nodes and relationships, based on the arguments the filter is applied. 

Here is an example for nodes filtering:

```cypher
EXPLAIN MATCH (n {id:1}) RETURN n;
```
```
+--------------------+
| QUERY PLAN         |
+--------------------+
| " * Produce {n}"   |
| " * Filter {n.id}" |
| " * ScanAll (n)"   |
| " * Once"          |
+--------------------+

```

Here is an example for relationships filtering based on the relationship properties:

```cypher
EXPLAIN MATCH (p)-[r{id:1}]->(t) RETURN r;
```
```
+--------------------------+
| QUERY PLAN               |
+--------------------------+
| " * Produce {r}"         |
| " * Filter {r.id}"       |
| " * Expand (t)<-[r]-(p)" |
| " * ScanAll (t)"         |
| " * Once"                |
+--------------------------+
```

In the example above, the `Expand` operator is used to expand from the `t` node to the `p` node. The `Expand` operator is used to find connected nodes based on the relationship, type and direction. 
It is and equivalent to the graph traversals/hops. The similar filter is `ExpandVariable` operator, which is used to perform a node expansion of several traversals or hops from the starting node.

Here is an example of the `ExpandVariable` operator:

```cypher
EXPLAIN MATCH (p)-[*1..2]-(t) RETURN p, t;
```
```
+-------------------------------------+
| QUERY PLAN                          |
+-------------------------------------+
| " * Produce {p, t}"                 |
| " * ExpandVariable (t)-[anon1]-(p)" |
| " * ScanAll (t)"                    |
| " * Once"                           |
+-------------------------------------+
```
`anon1` in this case means the relationship is anonymous and it is not named in the query, hence it can be anyrelationship between the nodes `p` and `t`, that is two traversals or hops away. 

`ScanAll` and `Filter` operators can be replaced with the `ScanAllByLabel`, `ScanAllByLabelProperty`, `ScanAllByLabelPropertyRange`, `ScanAllByLabelPropertyValue` operators, which are used to produce nodes with a certain label and property,
and are typcially indexed. Here is a pratical example: 

```cypher
EXPLAIN MATCH (n:Transfer{year:1992}) RETURN n;
```
```
+-------------------------------------+
| QUERY PLAN                          |
+-------------------------------------+
| " * Produce {n}"                    |
| " * Filter (n :Transfer), {n.year}" |
| " * ScanAll (n)"                    |
| " * Once"                           |
+-------------------------------------+
```

If you create and index on `:Transfer` label, the `ScanAll` operator will be replaced with the `ScanAllByLabel` operator, which is used to produce nodes with a certain label, minimizing search. 

CREATE INDEX ON :Transfer;

Now the same query, has a different query plan: 

```cypher
CREATE INDEX ON :Transfer;
EXPLAIN MATCH (n:Transfer{year:1992}) RETURN n;
```
```
+-----------------------------------+
| QUERY PLAN                        |
+-----------------------------------+
| " * Produce {n}"                  |
| " * Filter {n.year}"              |
| " * ScanAllByLabel (n :Transfer)" |
| " * Once"                         |
+-----------------------------------+
```
Adding a label propery index will optimize the query plan and the query execution, and replace the `ScanAll` operator with the `ScanAllByLabelPropertyValue` operator.

```cypher
CREATE INDEX ON :Transfer(year);
EXPLAIN MATCH (n:Transfer{year:1992}) RETURN n;

```

```
+-------------------------------------------------------+
| QUERY PLAN                                            |
+-------------------------------------------------------+
| " * Produce {n}"                                      |
| " * ScanAllByLabelPropertyValue (n :Transfer {year})" |
| " * Once"                                             |
+-------------------------------------------------------+
```

Indexes, constraints and datset cardinality statistics can influence how the query plan is being generated, 
for details on how to optimize the query plan execution, read the [performance guide](./performance-optimization.md)


## Query plan catching

There are multiple steps involved in running a query, that involve parsing, planning, and execution. 

The query plan is produced in the planning step, and it is used to optimize the query execution. The optimal query plan is the fastest and least reasource intensive
plan that can be produced for the given query by the query engine. In order speed up query execution, the query plan is being cached for later use, it does not need to be 
calculated for each query execution.

Let's imagine that you have multiple create queries: 

```cypher
CREATE (n:Node {id: 123}); 
CREATE (n:Node {id: 154}); 
CREATE (n:Node {id: 322}); 
...
```
Each of the queries will have the similar query plan that looks like this: 
```
+------------------+
| QUERY PLAN       |
+------------------+
| " * EmptyResult" |
| " * CreateNode"  |
| " * Once"        |
+------------------+
```

But each query string is different. To create a single query plan for each of the queries, the query parser will automaticly strip the literals and replace them with placeholder values, 
so each concecutive query can reuse the query plan. 

The same can be achived with using a query parameters, to ensure that the query plan is being reused, use parametrized queries like this: 

```cypher
CREATE (n:Node {id: $id}); 
CREATE (n:Node {id: $id});
CREATE (n:Node {id: $id});
...
```
The example above now has a single string for different queries, and the query plan will be reused. 



To validate the query plan caching, you can use the `PROFILE` clause to see if the query plan is being reused by comparing the execution time. 

```cypher
//Query 1
Additional execution time info:
  Query COST estimate: 0
  Query PARSING time: 0.00170783 sec
  Query PLAN EXECUTION time: 9.8768e-05 sec
  Query PLANNING time: 0.001479502 sec

//Query 2
Additional execution time info:
  Query COST estimate: 0
  Query PARSING time: 8.0453e-05 sec
  Query PLAN EXECUTION time: 7.1126e-05 sec
  Query PLANNING time: 7.6255e-05 sec

```

As you can see in the example above the the Query PlANNING time and is significantly lower for the second query, which means that the query plan is being reused.


<Callout type="warning">
The query plan caching is not supported for the [custom Query modules](../custom-query-modules.mdx).
</Callout>

Currently if you are using the [custom Query modules](../custom-query-modules.mdx), the query plan caching is not supported, and the query plan will be re-generated for each query executed. 
Since the custom query modules are dynamic and can change, the query plan could reference the old version of the query module, and produce incorrect results. 


Adding an index to the database will invalidate the query plan cache storage. The query plan cache is invalidated when the schema of the database changes, such as adding or removing an index, or adding or removing a constraint.
The reason for this is that the query plan is being optimized based on the schema of the database, and if the schema changes, the query plan could produce inefficent and outdated results. Hence it is necessary to invalidate the query plan cache, and re-grenarete the 
query plans on execution of the query.


<Callout type="warning">
The query plan cache is also invalidated when database schema changes, such as adding or removing an index, or adding or removing a constraint.
</Callout>


The query plan cache is also invalidated when the database is restarted, there is currently no persistent storage for the query plan cache.


## Query plan configurations


Behavior of the query plan can be influenced by the [database configuration](../configuration/configuration-settings.mdx#Query) parameters on database startup. 


`--cartesian-product-enabled=true` - This parameter enables or disables the Cartesian product operator. The Cartesian product operator is used to apply the Cartesian product on the input it received. This means if 
you match two nodes, the Cartesian product operator will produce all possible combinations of the nodes. This is a very expensive operation and it should be used with caution. Default value is set to `true`.

Here is an example of the query plan with the `--cartesian-product-enabled=true` parameter:

```cypher
EXPLAIN MATCH (n), (m) RETURN n, m;
```
```
+------------------------+
| QUERY PLAN             |
+------------------------+
| " * Produce {n, m}"    |
| " * Cartesian {m : n}" |
| " |\\ "                |
| " | * ScanAll (n)"     |
| " | * Once"            |
| " * ScanAll (m)"       |
| " * Once"              |

+---------------------------+---------------------------+
| n                         | m                         |
+---------------------------+---------------------------+
| (:Person {name: "John"})  | (:Person {name: "John"})  |
| (:Person {name: "John"})  | (:Person {name: "Stan"})  |
| (:Person {name: "John"})  | (:Person {name: "Peter"}) |
| (:Person {name: "Stan"})  | (:Person {name: "John"})  |
| (:Person {name: "Stan"})  | (:Person {name: "Stan"})  |
| (:Person {name: "Stan"})  | (:Person {name: "Peter"}) |
| (:Person {name: "Peter"}) | (:Person {name: "John"})  |
| (:Person {name: "Peter"}) | (:Person {name: "Stan"})  |
| (:Person {name: "Peter"}) | (:Person {name: "Peter"}) |
+---------------------------+---------------------------+
```

In the database are three nodes, John, Stan and Peter, and the query is to match all nodes and return them, for each `n` node, the Cartesian product operator will produce all possible combinations of the `m` nodes.


`--query-cost-planner=true` - This parameter enables or disables the query cost planner. The query
 cost planner is used to estimate the cost of the query execution, and it integral pice of finding the optimal query plan.
 More complex queries will have multiple query plans that can yield semantically equivalend results. Based on the underlying cardinality of the data,
 the query cost planner will estimate the cost of the query execution and choose the optimal query plan. If query cost planner is not working, the first viable 
 plan will be used. Default value is set to `true`


`--query-max-plans=1000` - This parameter sets the maximum number of query plans that can be generated for a single query.
 The query engine will generate multiple query plans for a single query, and the query cost planner will choose the optimal query plan. This is 
 an upper limit on the number of query plans that can be generated for a single query. Default value is set to `1000`


`--query-plan-cache-max-size=1000` - This parameter sets the maximum number of query plans that can be stored in the query plan cache.
 The query plan cache is used to store the query plans for later use, so they do not need to be recalculated for each query execution.
 Default value is set to `1000`


 `--query-vertex-count-to-expand-existing=10` - Depeding on the configuration in graph, the query engine will decide to use regular `Expand` operator or indexed lookup `ScanAllByLabel` operator 
 for a scenario where the number of nodes to expand is less than the `query-vertex-count-to-expand-existing` parameter. Default value is set to `10`. 


`--query-execution-timeout-sec=600` - This parameter sets the maximum time in seconds that a query can run before it is terminated. Default value is set to `600` seconds.


