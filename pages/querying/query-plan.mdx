---
title: Query plan
description: Understand how to read and interpret the query plan
---

import { Callout } from "nextra/components";


# Query plan

Cypher is a declarative language. This means that you specify what you want to retrieve but not 
the steps on how to retrieve it. This means the Memgraph Query engine is responsible for 
determining the best way to execute the Cypher query.

To find the best way, Memgraph converts each Cypher query is into a query plan. Query plans are a way to 
understand how the Memgraph query engine will execute a query. Memgraph query engine can do many 
optimizations in the background but also make mistakes. Hence, the query plan is a valuable tool 
to understand query execution and identify potential performance issues.

## Query plan structure

The users just interact with the Cyher to tune the Query plan structure. The query plan is an internal tree-like data 
structure describing a pipeline of operations performed on the database to yield the results for a given query. 
Every node within a plan is known as a *operator* and describes a particular operation.

Because a plan represents a pipeline, the operators are iteratively
executed as data passes from one operator to the other. Every 
operator *pulls* data from the operator(s) preceding it, processes it
and passes it onto the operator next in the pipeline for further
processing.

Query plan can be obtained by prefixing any query with [`EXPLAIN`](./clauses/explain.md) or [`PROFILE`](./clauses/profile.md) clauses.

Here is the basic example of a produced query plan for a simple query:

```cypher
EXPLAIN MATCH (n) RETURN n;
```
```
+----------------+
| QUERY PLAN     |
+----------------+
|  * Produce {n} |
|  * ScanAll (n) |
|  * Once        |
+----------------+
```
<Callout type="info">
The query plan should be read from the bottom to the top.
</Callout>

The output of the query using the `EXPLAIN` clause is a representation of the produced plan. Every
operator within the plan starts with an asterisk character (`*`) and is
followed by its name (and sometimes additional information). The execution of
the query proceeds iteratively (generating one entry of the result set at a
time), with data flowing from the bottom-most operator(s) (the start of
the pipeline) to the top-most operator(s) (the end of the pipeline).

The resulting plan is a pipeline of 3 operators, as shown in the example above.
`Once` is the identity operator which does nothing and is always found
at the start of the pipeline, `ScanAll` is a  operator which iteratively
produces all of the nodes in the graph, and `Produce` is a operator
which takes data produced by another operator and produces data for the
query's result set.

In this case the `ScanAll` operator is producing all nodes from the graph, passing them to the 
`Produce` operator that is just returning the nodes to the user. This is a simple query data pipeline.

A simple example showcasing the fully general tree structure of the plan could be:

```cypher
EXPLAIN MERGE (n) RETURN n;
```

```
+------------------+
| QUERY PLAN       |
+------------------+
|  * Produce {n}   |
|  * Accumulate    |
|  * Merge         |
|  |\ On Match     |
|  | * ScanAll (n) |
|  | * Once        |
|  |\ On Create    |
|  | * CreateNode  |
|  | * Once        |
|  * Once          |
+------------------+
```

Starting from the bottom and skipping `Once` operator, the `Merge`  operator 
(constructed as a result of the `MERGE` construct) can take input from two operators, 
`On Match` or `On Create`. The `On Match` and `On Create` branches are "pulled from" only if a
match is found or a new vertex must be created. Each branch again has its own pipeline of 
 operators, starting with `Once` and being read from the bottom to the top.


The more complicated example showcases the tree-like structure of the plan with `Merge` would be this: 


```cypher
EXPLAIN MERGE (p:Person {name: 'Angela'})
ON MATCH SET p.found = TRUE
ON CREATE SET p.notFound = TRUE
RETURN p.name, p.notFound, p.found;
```

```
+------------------------------------------+
| QUERY PLAN                               |
+------------------------------------------+
|  * Produce {p.name, p.notFound, p.found} |
|  * Accumulate                            |
|  * Merge                                 |
|  |\ On Match                             |
|  | * SetProperty                         |
|  | * Filter (p :Person), {p.name}        |
|  | * ScanAll (p)                         |
|  | * Once                                |
|  |\ On Create                            |
|  | * SetProperty                         |
|  | * CreateNode                          |
|  | * Once                                |
|  * Once                                  |
+------------------------------------------+
```


In this example, each of the branches of the `Merge` operator has more  operators in the pipeline.
The `On Match` branch has a `Filter` operator, which filters the nodes based on the label and property, 
and `SetProperty` operator, which sets the property on the node. The `On Create` branch has a `CreateNode` operator,
which creates a new node, and `SetProperty` operator, which sets the property on the node.

By combining different  operators, the query engine can produce a wide variety of query plans that are data pipelines for 
executing queries and producing results. 



## Query plan operators 

Each of the mentioned operators in the query plan represents a particular operation that will be performed on the data. 

The following table lists all the operators currently supported by Memgraph:

| Operator                      | Description                                                                                                                |
| ----------------------------- | -------------------------------------------------------------------------------------------------------------------------- |
| `Accumulate`                    | Accumulates the input it received.                                                                                       |
| `Aggregate`                     | Aggregates the input it received.                                                                                        |
| `Apply`                         | Joins the returned symbols from two branches of execution.                                                               |
| `CallProcedure`                 | Calls a procedure.                                                                                                       |
| `Cartesian`                     | Applies the Cartesian product (the set of all possible ordered combinations consisting of one member from each of those sets) on the input it received. |
| `ConstructNamedPath`            | Creates a path.                                                                                                          |
| `CreateNode`                    | Creates a node.                                                                                                          |
| `CreateExpand`                  | Creates edges and  new nodes to connect with existing nodes.                                                             |
| `Delete`                        | Deletes nodes and edges.                                                                                                 |
| `EdgeUniquenessFilter`          | Filters unique edges.                                                                                                    |
| `EmptyResult`                   | Discards results from the previous operator.                                                                             |
| `EvaluatePatternFilter`         | Part of the filter operator that contains a sub-branch which yields either true or false.                                |
| `Expand`                        | Expands the node by finding the node's relationships.                                                                    |
| `ExpandVariable`                | Performs a node expansion of a variable number of relationships                                                          |
| `Filter`                        | Filters the input it received.                                                                                           |
| `Foreach`                       | Iterates over a list and applies one or more update clauses.                                                             |
| `HashJoin`                      | Performs a hash join of the input from its two input branches.                                                           |
| `IndexedJoin`                   | Performs an indexed join of the input from its two input branches.                                                       |
| `Limit`                         | Limits certain rows from the pull chain.                                                                                 |
| `LoadCsv`                       | Loads CSV file in order to import files into the database.                                                               |
| `Merge`                         | Applies merge on the input it received.                                                                                  |
| `Once`                          | Forms the beginning of an operator chain with "only once" semantics. The operator will return false on subsequent pulls. |
| `Optional`                      | Performs optional matching.                                                                                              |
| `OrderBy`                       | Orders the input it received.                                                                                            |
| `Produce`                       | Produces results.                                                                                                        |
| `RemoveLabels`                  | Removes a variable number of node labels.                                                                                |
| `RemoveProperty`                | Removes a node or relationship property.                                                                                 |
| `ScanAll`                       | Produces all nodes in the database.                                                                                      |
| `ScanAllById`                   | Produces nodes with a certain index.                                                                                     |
| `ScanAllByLabel`                | Produces nodes with a certain label.                                                                                     |
| `ScanAllByLabelProperty`        | Produces nodes with a certain label and property.                                                                        |
| `ScanAllByLabelPropertyRange`   | Produces nodes with a certain label and property value within the given range (both inclusive and exclusive).            |
| `ScanAllByLabelPropertyValue`   | Produces nodes with a certain label and property value.                                                                  |
| `SetLabels`                     | Sets node labels of variable length.                                                                                     |
| `SetProperty`                   | Sets a node or relationship property.                                                                                    |
| `SetProperties`                 | Sets a list of node or relationship properties.                                                                          |
| `Skip`                          | Skips certain rows from the pull chain.                                                                                  |
| `Unwind`                        | Unwinds an expression to multiple records.                                                                               |
| `Distinct`                      | Applies a distinct filter on the input it received.                                                                      |

Some of the operators are always present and bolierplate operators, such as `Once` and `Produce`. 

Some operators are always present and can be considered boilerplate operators, such as `Once` and `Produce.` 

`Once` is the operator that represents the first operator in the query plan, and it is always present.`Once` 
is used to signal the start of the query plan and to signal the start of the operator chain in other branches. 

`Produce` is the operator that represents the last operator in the query plan, and it is almost always 
present. It is used to signal the end of the query plan and connected to the usage of the `RETURN` clause in the query.
If nothing is returned, the `EmptyResult` will be part of the query plan, and not the `Produce`. 

Here is an example of the query plan with `Once` and `Produce` operators:

```cypher
EXPLAIN RETURN 0;
```

```
+------------------+
| QUERY PLAN       |
+------------------+
| " * Produce {0}" |
| " * Once"        |
+------------------+
```

`ScanAll` is the operator that represents the operator that produces all nodes in the database. This means that 
it will touch every node in the graph and it will  pass that data to the next operator in the query plan. This operator 
is used when there is no node filtering based on labels and properties, and it is expensive to use on large graphs.
Conside how to avoid usage of it, by reading the [performance guide](./performance-optimization.md).

```cypher
EXPLAIN MATCH (n) RETURN n;
```
```
+----------------+
| QUERY PLAN     |
+----------------+
|  * Produce {n} |
|  * ScanAll (n) |
|  * Once        |
+----------------+
```

`Filter` is the operator that filters the input it receives. This operator is used when filtering the 
nodes and relationship properties or labels. Typically, the `MATCH` clause arguments are used to filter the 
nodes and relationships based on the arguments the filter applies automatically. 

Here is an example of nodes filtering:

```cypher
EXPLAIN MATCH (n {id:1}) RETURN n;
```
```
+--------------------+
| QUERY PLAN         |
+--------------------+
| " * Produce {n}"   |
| " * Filter {n.id}" |
| " * ScanAll (n)"   |
| " * Once"          |
+--------------------+

```

Here is an example of relationships filtering based on the relationship properties:

```cypher
EXPLAIN MATCH (p)-[r{id:1}]->(t) RETURN r;
```
```
+--------------------------+
| QUERY PLAN               |
+--------------------------+
| " * Produce {r}"         |
| " * Filter {r.id}"       |
| " * Expand (t)<-[r]-(p)" |
| " * ScanAll (t)"         |
| " * Once"                |
+--------------------------+
```

In the example above, the `Expand` operator expands from the `t` node to the `p` node. The `Expand` 
operator finds connected nodes based on the relationship, type, and direction.  It is equivalent to the graph traversals/hops. 
A similar filter is the `ExpandVariable` operator, which is used to perform a node expansion of several 
traversals or hops from the starting node.

Here is an example of the `ExpandVariable` operator:

```cypher
EXPLAIN MATCH (p)-[*1..2]-(t) RETURN p, t;
```
```
+-------------------------------------+
| QUERY PLAN                          |
+-------------------------------------+
| " * Produce {p, t}"                 |
| " * ExpandVariable (t)-[anon1]-(p)" |
| " * ScanAll (t)"                    |
| " * Once"                           |
+-------------------------------------+
```
`anon1` in this case means the relationship is anonymous, and it is not named in the query. 
Hence, there can be any relationship between the nodes `p` and `t`, two traversals or hops away. 
 

`ScanAll` and `Filter` operators can be replaced with the `ScanAllByLabel`,
`ScanAllByLabelProperty`, `ScanAllByLabelPropertyRange`, `ScanAllByLabelPropertyValue` operators, 
which are used to produce nodes with a specific label and property, and are typically indexed. 

Here is a practical example: 

```cypher
EXPLAIN MATCH (n:Transfer{year:1992}) RETURN n;
```
```
+-------------------------------------+
| QUERY PLAN                          |
+-------------------------------------+
| " * Produce {n}"                    |
| " * Filter (n :Transfer), {n.year}" |
| " * ScanAll (n)"                    |
| " * Once"                           |
+-------------------------------------+
```

If you create an index on the `:Transfer` label, the `ScanAll` operator will be replaced with
the `ScanAllByLabel` operator, which is used to produce nodes with a specific label, minimizing search. 

Now the same query has a different query plan: 

```cypher
CREATE INDEX ON :Transfer;
EXPLAIN MATCH (n:Transfer{year:1992}) RETURN n;
```
```
+-----------------------------------+
| QUERY PLAN                        |
+-----------------------------------+
| " * Produce {n}"                  |
| " * Filter {n.year}"              |
| " * ScanAllByLabel (n :Transfer)" |
| " * Once"                         |
+-----------------------------------+
```

Adding a label-property index will optimize the query plan and
execution and replace the `ScanAll` operator with the `ScanAllByLabelPropertyValue` operator. 
This will further optimize the query plan and execution.

```cypher
CREATE INDEX ON :Transfer(year);
EXPLAIN MATCH (n:Transfer{year:1992}) RETURN n;

```

```
+-------------------------------------------------------+
| QUERY PLAN                                            |
+-------------------------------------------------------+
| " * Produce {n}"                                      |
| " * ScanAllByLabelPropertyValue (n :Transfer {year})" |
| " * Once"                                             |
+-------------------------------------------------------+
```


Indexes, constraints, and data cardinality statistics can influence how the query plan is being generated. 
Memgraph has [`ANALYZE GRAPH`](./performance-optimization.md#Analyze-graph) and [index hinting](./performance-optimization.md#index-hinting) 
to influence the query plan generation, for details on how to optimize the query plan execution and use these features,
read the [performance guide](./performance-optimization.md)


## Query plan Caching

There are multiple steps involved in running a query, including parsing, planning, and execution. 

The query plan is produced in the planning step, and it is used to optimize the
query execution. The optimal query plan is the fastest and least resource-intensive
plan that can be produced for the query given by the query engine. In order to speed up 
query execution, the query plan is being cached for later use; it does not need to be 
calculated for each query execution.

Let's imagine that you have multiple create queries: 

```cypher
CREATE (n:Node {id: 123}); 
CREATE (n:Node {id: 154}); 
CREATE (n:Node {id: 322}); 
...
```
Each of the queries will have a similar query plan that looks like this: 
```
+------------------+
| QUERY PLAN       |
+------------------+
| " * EmptyResult" |
| " * CreateNode"  |
| " * Once"        |
+------------------+
```

But each query string is different, to create a single query plan for each of the queries, the query parser will automatically strip the literals and replace them with placeholder values, 
so each consecutive query can reuse the query plan. 

TODO: Example

The same can be achieved by using query parameters. To ensure that the query plan is being reused, use parametrized queries like this:  


```cypher
CREATE (n:Node {id: $id}); 
CREATE (n:Node {id: $id});
CREATE (n:Node {id: $id});
...
```
The example above now has a single string for different queries, and the query plan will be reused. 


To validate the query plan caching, you can use the [query execution time summary](getting-started/cli#query-execution-time) to see the additional execution time info.

```cypher
//Query 1
Additional execution time info:
  Query COST estimate: 0
  Query PARSING time: 0.00170783 sec
  Query PLAN EXECUTION time: 9.8768e-05 sec
  Query PLANNING time: 0.001479502 sec

//Query 2
Additional execution time info:
  Query COST estimate: 0
  Query PARSING time: 8.0453e-05 sec
  Query PLAN EXECUTION time: 7.1126e-05 sec
  Query PLANNING time: 7.6255e-05 sec

```

As you can see in the example above, the Query PlANNING time is significantly lower for the second query, which means that the query plan is being reused


<Callout type="warning">
The query plan caching is not supported for the [custom Query modules](../custom-query-modules.mdx).
</Callout>

Currently, if you are using the [custom Query modules](../custom-query-modules.mdx), the query plan caching is 
not supported, and the query plan will be re-generated for each query executed.  Since the custom query modules are dynamic 
and can change, the query plan could reference the old version of the query module and produce incorrect results. 


Adding an index to the database will invalidate the query plan cache storage. The query plan cache is invalidated 
when the schema of the database changes, such as adding or removing an index or adding or removing a constraint.
The reason for this is that the query plan is being optimized based on the schema of the database, and if the 
schema changes, the query plan could produce inefficient and outdated results. Hence it is necessary to 
invalidate the query plan cache and re-generate the query plans on the execution of the query.


<Callout type="warning">
The query plan cache is also invalidated when database schema changes, such as adding or removing an index or adding or removing a constraint.
</Callout>


The query plan cache is also invalidated when the database is restarted, there is currently 
no persistent storage for the query plan cache.


## Query plan configurations


The behavior of the query plan can be influenced by the [database configuration](../configuration/configuration-settings.mdx#Query) parameters on database startup. 


`--cartesian-product-enabled=true` - This parameter enables or disables the Cartesian product operator. The Cartesian product operator is used to apply the Cartesian product to the input it receives. This means if 
you match two nodes, the Cartesian product operator will produce all possible combinations of the nodes. This is a costly operation, and it should be used with caution. The default value is set to `true`.

Here is an example of the query plan with the `--cartesian-product-enabled=true` parameter:

```cypher
EXPLAIN MATCH (n), (m) RETURN n, m;
```
```
+------------------------+
| QUERY PLAN             |
+------------------------+
| " * Produce {n, m}"    |
| " * Cartesian {m : n}" |
| " |\\ "                |
| " | * ScanAll (n)"     |
| " | * Once"            |
| " * ScanAll (m)"       |
| " * Once"              |

+---------------------------+---------------------------+
| n                         | m                         |
+---------------------------+---------------------------+
| (:Person {name: "John"})  | (:Person {name: "John"})  |
| (:Person {name: "John"})  | (:Person {name: "Stan"})  |
| (:Person {name: "John"})  | (:Person {name: "Peter"}) |
| (:Person {name: "Stan"})  | (:Person {name: "John"})  |
| (:Person {name: "Stan"})  | (:Person {name: "Stan"})  |
| (:Person {name: "Stan"})  | (:Person {name: "Peter"}) |
| (:Person {name: "Peter"}) | (:Person {name: "John"})  |
| (:Person {name: "Peter"}) | (:Person {name: "Stan"})  |
| (:Person {name: "Peter"}) | (:Person {name: "Peter"}) |
+---------------------------+---------------------------+
```

In the database are three nodes, John, Stan, and Peter, and the query is to match all nodes and return them; for each `n` node, the Cartesian product operator will produce all possible combinations of the `m` nodes.


`--query-cost-planner=true` - This parameter enables or disables the query cost planner. The query
 A cost planner is used to estimate the cost of the query execution, and it is an integral part of finding the optimal query plan.
 More complex queries will have multiple query plans that can yield semantically equivalent results. Based on the underlying cardinality of the data,
 the query cost planner will estimate the cost of the query execution and choose the optimal query plan. If the query cost planner is not working, the first viable 
 plan will be used. The default value is set to `true`


`--query-max-plans=1000` - This parameter sets the maximum number of query plans that can be generated for a single query.
 The query engine will generate multiple query plans for a single query, and the query cost planner will choose the optimal query plan. This is 
 an upper limit on the number of query plans that can be generated for a single query. The default value is set to `1000`


`--query-plan-cache-max-size=1000` - This parameter sets the maximum number of query plans that can be stored in the query plan cache.
 The query plan cache is used to store the query plans for later use, so they do not need to be recalculated for each query execution.
 The default value is set to `1000`


 `--query-vertex-count-to-expand-existing=10` - Depending on the configuration in the graph, the query engine will decide to use regular `Expand` operator or indexed lookup `ScanAllByLabel` operator 
 for a scenario where the number of nodes to expand is less than the `query-vertex-count-to-expand-existing` parameter. The default value is set to `10`. 


`--query-execution-timeout-sec=600` - This parameter sets the maximum time in seconds that a query can run before it is terminated. The default value is set to `600` seconds.

