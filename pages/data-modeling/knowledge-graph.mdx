---
title: Memgraph Knowledge Graph
description: Learn how to create a knowledge graph using Memgraph.
---

import { Callout } from 'nextra/components'
import { Card, Cards } from 'nextra/components'

# Knowledge graph

From the business perspective, a knowledge graph represents how you organize and
represent your data. Hence, it encodes the knowledge about your use case, which
can be explored and fetched. Knowledge is encoded in the graph's structure in
the form of **nodes**, **relationships** and **properties**. 

From the operational and developer perspective, knowledge graphs represent just
a specific way of organizing and storing your data in the graph. Following
particular organization techniques, you can encode complex relationships between
different entities in your domain.

Knowledge graphs help developers to:

- **Understand complex relationships**: They reveal hidden patterns and
 connections between entities, which might not be obvious in traditional
 relational systems.
- **Enhance data discovery**: By representing data as a graph, you can traverse
 relationships and uncover new insights or trends in the data.
- [**Power AI applications**](/pages/ai-ecosystem/graph-rag.mdx): KGs are foundational in building recommendation
 engines, semantic search systems, and various agent-driven applications,
 offering more context-aware and intelligent results.
- **Enable flexible querying**: Queries can be more dynamic and powerful,
 allowing for complex graph traversals and relationship-based searches that are
 harder to achieve in SQL databases.


This guide will help you understand how to create a knowledge graph using
Memgraph.

## Memgraph as a knowledge graph

Memgraph is a database based on the label property graph (LPG), that makes it a
perfect choice for creating a knowledge graph because LPG is one of the most
flexible ways you can describe your domain knowledge in the graph format.
Resource Description Framework (RDF) is another popular way to model knowledge,
but it is more rigid and less flexible than LPG, which is why LPG is more suited
for knowledge graphs. 

The LPG model shares the same basis with the general
concepts of how the graph should be modeled and how the data should be stored.
For more details on the possibilities of You can check the [graph
modeling](/fundamentals/graph-modeling.md) section for LPG modeling.

On top of being an LPG database, Memgraph is also a high-performance, in-memory
graph database that can handle complex queries and large datasets. Graph hops
are a critical part of traversals in the graph, Memgraph is optimized for fast
graph traversals and complex queries, which are essential for knowledge graph
applications.

## Knowledge Graph example 

This guide will use a simple example of a knowledge graph representing a project
management scenario. Let's assume you have a dataset that contains information
about people, their skills, the companies they work for, tasks they need to do,
tasks that are part of the project, and the project that the client requests.
Initially, this is our graph model: 


![Initial Graph
Model](/pages/data-modeling/knowledge-graph/project-management-graph.png)


Depending on the answers you want to get from the knowledge graph, it can help
you with different aspects of the project management, such as: 

- Efficient Resource Allocation
- Project Planning and Tracking
- Skill Gap Analysis
- Improved Client Management
- Cross-domain expertise and Flexibility
- Cost Optimization

The focus of the knowledge graph could be to answer questions like: 

- Do people have sufficient skills to perform all the tasks they are working on?
- Are we able to execute all the projects?
- Do we have missing gaps in skills that we need to fill?
- Does the budget cover the cost of people with sufficient skills to work on
 that project?
- Do employees work on tasks that match their domain preferences?


### Answering questions without the knowledge graph

As the question starts to pop up, you can start thinking about how to write a
Cypher query to help you answer those questions. 

Take the question: "Do people have sufficient skills to perform all the tasks
they are working on?"

You could do a match query that will return all the people that work on some
tasks, and check if they have the skill to perform the task: the query would
look like this:

```cypher 
MATCH (p:Person)-[:WORKS_ON]->(t:Task)
WHERE all(skill IN t.Skills WHERE skill IN p.Skills)
RETURN *
```

The problem with this approach is that you need to know the structure of the
graph, what skills represent the person and task nodes, and how they are even
correlated. 

In this case, the knowledge is built into the query that you, as a data analyst
or the developer needs to write that it was not natively encoded into the graph.
On top of that, the knowledge was pre-defined in terms of questions you want to
answer, so it was easier to infer knowledge from the graph model by writing
specific query to answer specific quesiton.

Imagine that you have decided to enable a software agent in the form of LLM to
answer the same question. 

This means that LLM needs to know how to write a query that will match that
specific graph ontology, which is not an easy task. The second option would be
to encode the knowledge into the graph so that LLM only needs to get the pivot
point in the form of a node or relationship and perform **relevance expansion**.
The relevance expansion is the process of expanding the data around the pivot
point and providing the context to the LLM model so it can predict tha answer
based on data. The example of relevance expansion can be done by performing two
hops in the graph from the pivot point. 
 

### Encoding knowledge into the graph

Based on the previous example,  it is all about skills, relationships with
employees, and tasks. In order to improve a graph ontology, the skill needs to
become a class, or node in this case. 

So now you have a graph mode that looks like this:

![Improved knowledge
graph](/pages/data-modeling/knowledge-graph/project-management-progression-graph.png)

In this case, the relationship of the skills with tasks is encoded into the
graph. The knowledge about the skills is encoded into the graph model. 

Notice how the relationships `HAS` between `Person` and `Skill` and the
relationship `NEEDS` between `Task` and `Skill` are now semantically describing
the relationship's meaning.

Now you can write a query that will answer the question: "Do people have
sufficient skills to perform all the tasks they are working on?". 

These are people who have sufficient skills to perform all the tasks they are
working on:

```cypher
MATCH (p:Person)-[h:HAS]->(s:Skill)<-[n:NEEDS]-(t:Task)
WHERE exists((p)-[:WORKS_ON]->(t))
RETURN *
```

These are the people who do not have sufficient skills to perform the tasks they
are working on:

```cypher
MATCH (p:Person)-[w:WORKS_ON]->(t:Task)-[n:NEEDS]->(s:Skill)
WHERE NOT exists((p)-[:HAS]->(s))
RETURN *
```

You still need to write the query to fetch the data, but the query uses more
graph structure and has the semantics of the graph model. This can be used to
infer knowledge from the graph and answer questions that are not even defined in
the first place.

### Making the knowledge graph 

The process of encoding the knowledge includes modeling the graph to represent
the domain knowledge most accurately. There is no a one-size-fits-all approach
to modeling a knowledge graph, as it depends on the specific use case and the
questions you want to answer.

In general, you want to extract all the entities and relationships that are
relevant to your domain and represent them as nodes and edges in the graph. This
often means pulling out node properties and relationships from the data and
creating a graph schema that captures their connections.

Here is a complete graph model that will help you to answer more questions: 

![Complete knowledge
graph](/pages/data-modeling/knowledge-graph/project-management-full-graph.png)

Notice that from the initial model with the same data inside but only four nodes
and three relationship types, we now have six nodes and nine relationship types.
This graph model is more complex and semantically rich, and it can be used to
answer more complex questions about the project management scenario. Even just
by glancing at the model, you have a better understanding of what is happening. 


Here is an example of another question you could ask: "Are we able to execute
For all the projects, do we have gaps in skills missing?"

Without writing the query, it should be clear from the graph model how to answer
this question. 

For the sake of the example, here is the query: 

```cypher
MATCH (p:Project)-[:REQUIRES]->(s:Skill)
OPTIONAL MATCH (person:Person)-[:HAS]->(s)
WITH p, s, collect(person) AS peopleWithSkill
WHERE size(peopleWithSkill) = 0
RETURN p.name AS UnfulfillableProject, collect(s.name) AS MissingSkills;
```

As you can see, there is a project that requires a skill that no one in the
company has. This is the result of the query:

```
+----------------------+----------------------+
| UnfulfillableProject | MissingSkills        |
+----------------------+----------------------+
| "AI Integration"     | ["Machine Learning"] |
+----------------------+----------------------+
```

But again, we have written the query to fetch the data, but the knowledge about
the skills and projects are encoded into the graph model. 


### Knowledge graph and AI agents

Now, without writing the logic in the query, try to pass the data into the LLM
model for a particular project, take some relevance and ask some questions. 

```cypher
MATCH path=(p:Project {name:"Data Preprocessing"})-[r *..2]-(n) RETURN path;
```

The query above will find the project "Data Preprocessing" and fetch the data 2
hops away from the project. There is no specific question that we are asking,
but we are pulling the data that is relevant to the project.

 Now, passing that information to the LLM model, we can ask questions like:

"Are we able to execute this project?" 

Here is the response of the LLM model (short version):

```plaintext

Project Overview

- Project Name: Data Preprocessing
 - Budget: $50,000
 - Start Date: 2024-10-01
 - End Date: 2024-11-30
 - Total Duration: 60 days

Tasks and Requirements

- Task Name: Data Cleaning
 - Description: Clean and preprocess raw data
 - Estimated Man-Days: 10 days
 - Required Skill: Data Analysis (inferred from the relationship)

Personnel Involved

- Person: Jane Smith
 - Cost per Day: $600
 - Skills: Data Analysis (inferred from the relationship)

Conclusion

Based on the analysis, the project does have a sufficient level of skilled
personnel to fulfill the requirements, as Jane Smith is qualified for the
necessary task. Additionally, the budget is adequate to cover her costs, with a
significant amount remaining for any additional needs or tasks that may arise.
```

Now, if you look closely, the LLM model has inferred some knowledge from the
knowledge graph. Without even thinking about specific things you want to ask, it
predicts what the answer is based on the data in the knowledge graph.

Passing in the same data and asking the question: "Do employees work on tasks
and projects that match their domain preferences?"

Here is the response of the LLM model:


```plaintext
Yes, it appears that people are working on tasks they are interested in:

Task Interest Alignment: Jane Smith, who is assigned to work on the "Data
Cleaning" task, has a preference for the Data Science domain, which is related
to this task. This alignment suggests she is working within an area of interest.

Skills and Preferences: Jane possesses the Data Analysis skill, which is also a
requirement for the project and a direct need for the "Data Cleaning" task. This
indicates that her skills and interests align with her assigned
responsibilities. 

This structure suggests that team members like Jane are indeed
working on tasks that match both their skills and their domain preferences,
which can enhance motivation and project outcomes.
```

### Dataset

If you want to create the knowledge graph in Memgraph, and test this example, here is the dataset that you can use to seed the graph:

```cypher
// Create Persons with their attributes
CREATE (john:Person {firstName: "John", lastName: "Doe", costPerDay: 500});
CREATE (jane:Person {firstName: "Jane", lastName: "Smith", costPerDay: 600});

// Create Skills
CREATE (python:Skill {name: "Python"});
CREATE (dataAnalysis:Skill {name: "Data Analysis"});

// Create Domains
CREATE (softwareDevelopment:Domain {name: "Software Development"});
CREATE (dataScience:Domain {name: "Data Science"});

// Create Tasks with their attributes
CREATE (task1:Task {name: "Develop Backend", description: "Develop backend API using Python", manDays: 15});
CREATE (task2:Task {name: "Data Cleaning", description: "Clean and preprocess raw data", manDays: 10});

// Create Projects with their attributes
CREATE (project1:Project {name: "Backend API Development", startDate: date("2024-11-01"), endDate: date("2024-12-15"), budget: 100000});
CREATE (project2:Project {name: "Data Preprocessing", startDate: date("2024-10-01"), endDate: date("2024-11-30"), budget: 50000});

// Create Clients with their attributes
CREATE (client1:Client {name: "TechCorp", size: "Large"});
CREATE (client2:Client {name: "DataSolutions", size: "Medium"});

// Create Relationships

// Match John and Python, then create HAS relationship
MATCH (john:Person {firstName: "John", lastName: "Doe"}), (python:Skill {name: "Python"})
CREATE (john)-[:HAS]->(python);

// Match John and Software Development, then create PREFERS relationship
MATCH (john:Person {firstName: "John", lastName: "Doe"}), (softwareDevelopment:Domain {name: "Software Development"})
CREATE (john)-[:PREFERS]->(softwareDevelopment);

// Match Jane and Data Analysis, then create HAS relationship
MATCH (jane:Person {firstName: "Jane", lastName: "Smith"}), (dataAnalysis:Skill {name: "Data Analysis"})
CREATE (jane)-[:HAS]->(dataAnalysis);

// Match Jane and Data Science, then create PREFERS relationship
MATCH (jane:Person {firstName: "Jane", lastName: "Smith"}), (dataScience:Domain {name: "Data Science"})
CREATE (jane)-[:PREFERS]->(dataScience);

// Match John and Task1, then create WORKS_ON relationship
MATCH (john:Person {firstName: "John", lastName: "Doe"}), (task1:Task {name: "Develop Backend"})
CREATE (john)-[:WORKS_ON]->(task1);

// Match Jane and Task2, then create WORKS_ON relationship
MATCH (jane:Person {firstName: "Jane", lastName: "Smith"}), (task2:Task {name: "Data Cleaning"})
CREATE (jane)-[:WORKS_ON]->(task2);

// Match Task1 and Python, then create NEEDS relationship
MATCH (task1:Task {name: "Develop Backend"}), (python:Skill {name: "Python"})
CREATE (task1)-[:NEEDS]->(python);

// Match Task1 and Software Development, then create RELATED relationship
MATCH (task1:Task {name: "Develop Backend"}), (softwareDevelopment:Domain {name: "Software Development"})
CREATE (task1)-[:RELATED]->(softwareDevelopment);

// Match Task1 and Project1, then create PART_OF relationship
MATCH (task1:Task {name: "Develop Backend"}), (project1:Project {name: "Backend API Development"})
CREATE (task1)-[:PART_OF]->(project1);

// Match Task2 and Data Analysis, then create NEEDS relationship
MATCH (task2:Task {name: "Data Cleaning"}), (dataAnalysis:Skill {name: "Data Analysis"})
CREATE (task2)-[:NEEDS]->(dataAnalysis);

// Match Task2 and Data Science, then create RELATED relationship
MATCH (task2:Task {name: "Data Cleaning"}), (dataScience:Domain {name: "Data Science"})
CREATE (task2)-[:RELATED]->(dataScience);

// Match Task2 and Project2, then create PART_OF relationship
MATCH (task2:Task {name: "Data Cleaning"}), (project2:Project {name: "Data Preprocessing"})
CREATE (task2)-[:PART_OF]->(project2);

// Match Project1 and Python, then create REQUIRES relationship
MATCH (project1:Project {name: "Backend API Development"}), (python:Skill {name: "Python"})
CREATE (project1)-[:REQUIRES]->(python);

// Match Project1 and Software Development, then create RELATED relationship
MATCH (project1:Project {name: "Backend API Development"}), (softwareDevelopment:Domain {name: "Software Development"})
CREATE (project1)-[:RELATED]->(softwareDevelopment);

// Match Project2 and Data Analysis, then create REQUIRES relationship
MATCH (project2:Project {name: "Data Preprocessing"}), (dataAnalysis:Skill {name: "Data Analysis"})
CREATE (project2)-[:REQUIRES]->(dataAnalysis);

// Match Project2 and Data Science, then create RELATED relationship
MATCH (project2:Project {name: "Data Preprocessing"}), (dataScience:Domain {name: "Data Science"})
CREATE (project2)-[:RELATED]->(dataScience);

// Match Client1 and Project1, then create REQUESTED relationship
MATCH (client1:Client {name: "TechCorp"}), (project1:Project {name: "Backend API Development"})
CREATE (client1)-[:REQUESTED]->(project1);

// Match Client2 and Project2, then create REQUESTED relationship
MATCH (client2:Client {name: "DataSolutions"}), (project2:Project {name: "Data Preprocessing"})
CREATE (client2)-[:REQUESTED]->(project2);

// Create a new Person without the appropriate skill and outside their domain of interest
CREATE (mike:Person {firstName: "Mike", lastName: "Johnson", costPerDay: 400});

// Create a new Skill that Mike does NOT have
CREATE (java:Skill {name: "Java"});

// Create a new Domain that Mike PREFERS
CREATE (marketing:Domain {name: "Marketing"});

// Create a new Task that requires a skill Mike does NOT have and is outside his domain of interest
CREATE (task3:Task {name: "Develop Mobile App", description: "Develop a mobile app using Java", manDays: 20});

// Create a new Domain for the Task that is different from Mike's preferred domain
CREATE (mobileDevelopment:Domain {name: "Mobile Development"});

// Create a new Project for this Task
CREATE (project3:Project {name: "Mobile App Development", startDate: date("2024-12-01"), endDate: date("2025-01-30"), budget: 80000});

// Create Relationships

// Match Mike and Marketing, then create PREFERS relationship
MATCH (mike:Person {firstName: "Mike", lastName: "Johnson"}), (marketing:Domain {name: "Marketing"})
CREATE (mike)-[:PREFERS]->(marketing);

// Match Task3 and Java (the skill Mike does NOT have), then create NEEDS relationship
MATCH (task3:Task {name: "Develop Mobile App"}), (java:Skill {name: "Java"})
CREATE (task3)-[:NEEDS]->(java);

// Match Task3 and Mobile Development (a domain that Mike is NOT interested in), then create RELATED relationship
MATCH (task3:Task {name: "Develop Mobile App"}), (mobileDevelopment:Domain {name: "Mobile Development"})
CREATE (task3)-[:RELATED]->(mobileDevelopment);

// Match Mike and Task3 (even though Mike lacks the appropriate skill and is working outside his preferred domain), then create WORKS_ON relationship
MATCH (mike:Person {firstName: "Mike", lastName: "Johnson"}), (task3:Task {name: "Develop Mobile App"})
CREATE (mike)-[:WORKS_ON]->(task3);

// Match Task3 and Project3, then create PART_OF relationship
MATCH (task3:Task {name: "Develop Mobile App"}), (project3:Project {name: "Mobile App Development"})
CREATE (task3)-[:PART_OF]->(project3);

```

## Memgraph's office hours

Schedule a 30 min session with one of our engineers to discuss how Memgraph fits
with your architecture. Our engineers are highly experienced in helping
companies of all sizes to integrate and get the most out of Memgraph in their
projects. Talk to us about data modeling, optimizing queries, defining
infrastructure requirements or migrating from your existing graph database. No
nonsense or sales pitch, just tech.

![](/pages/getting-started/memgraph-office-hours.svg)

<Cards>
  <Card
    title="Book a call"
    href="https://memgraph.com/office-hours"
  />
</Cards>



