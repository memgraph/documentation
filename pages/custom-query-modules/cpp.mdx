---
title: How to create a query module in C++
description: Enhance your graph data analysis by integrating the C++ programming language with Memgraph. Explore C++ and other languages further in our documentation.
---

import { Callout } from 'nextra/components'

# How to create a query module in C++

As C++ requires compiling, you cannot use its source code directly; it must first be compiled into a shared library. This shared library can then be loaded by Memgraph and utilized as a query module.

To achieve this, an environment equipped for compiling C++, including necessary libraries, headers, and a compiler, needs to be established on the system or within a development container.

Given these requirements, you have two primary options for developing a C++ query module:

- [Developing in your own environment](/custom-query-modules/cpp/cpp-example#quickstart-gude-for-developing-a-query-module-in-c)
- [Utilizing the MAGE environment](/custom-query-modules/cpp/cpp-example#developing-a-query-module-with-mage)

When developing in your own environment, you will manage only your dependencies.
This setup is compatible with any Memgraph installation or container and doesn't
necessitate MAGE. Here, you will manually install the required dependencies and
compile the shared library.

Alternatively, the MAGE environment contains all dependencies and files
necessary for the Mage library to function properly. In this setup, you will
follow the Mage structure to integrate your own query modules and compile them
alongside Mage.

## How C++ API works in Memgraph 

The C++ API acts as a wrapper around the [C API](/custom-query-modules/c/c-api).
The  [C++ API](/custom-query-modules/cpp/cpp-api) provides a full range of
supported functions with automatic memory management. C++ API modules, just like
C API modules, need
to be compiled into a shared library so that they can be loaded when Memgraph starts. 

This means the C++ shared library is directly tied to the Memgraph instance that loaded it and shares the same resources, which leads to quite efficient performance. 
As a result, unhandled exceptions in the C++ code can crash the Memgraph instance, making it important to handle all exceptions.