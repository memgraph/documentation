---
title: Example of a query module written in C++
description: pages/custom-query-modules/cpp/cpp-example.mdx
---

import { Callout } from 'nextra/components'
import { Steps } from 'nextra/components'

# Custom query module in C++ 

Query modules can be implemented using the [C++ API
](/custom-query-modules/cpp/cpp-api). The C++ API is a wrapper around the C
API, which means that all of the C API functions are available in C++ as well.
These modules need to be compiled to a shared library format or `.so` files so that they can be loaded 
when Memgraph starts. 

## Quickstart gude for developing a query module in C++

In order to start working on a query module, you need to have an Memgraph instance running. The instance will also be used as a development enviroment for your query module. 
This will provide you with isolated enviroment for testing and developing your query module. In order to acoplish this, you need to to have docker installed on your machine.

- [Docker](https://docs.docker.com/get-docker/)


<Steps>

### Run Memgraph

First, you need to run Memgraph instance. You can do this by running the following command:

```bash
docker run -p 7687:7687 -p 7444:7444 -p 3000:3000 --name memgraph memgraph/memgraph-platform
```

Keep in mind that you can use image with just MemgraphDB, Mage or Platform. It won't change the way you develop your query module.
Since all of the header files defining the C++ and C API are included in the image, and you can use any of them.

### Enter into memgraph container shell

After you have started the Memgraph instance, you need to enter the shell. You can do this by running the following command:

```bash
docker exec -u 0 -it memgraph bash
```

This will start bash inside the container4 as root user. Since we need to install and compile stuff, we need to be root user.

### Install the required dependecies 

In order to install the required dependecies, you need to run the following command:

```bash
 apt update -y
 apt install -y git cmake gcc g++ vim
```

Ofcourse if you do not want to use the vim, you can use any other text editor, the same goes for the Cmake. You can use any other build system you want, or call the compiler directly.

### Create a directory for your query module

Now that we have all of the required dependecies installed, we can create a directory for our query module. You can do this by running the following command:

```bash
mkdir /hello_query_module
cd hello_query_module
```

### Develop a sample query module 

Now that we have a directory for our query module, we can create a sample query module. You can do this by running the following command:

```bash
vim hello_query_module.cpp
```

This will open vim editor. You can copy the following code into the editor:

```cpp
#include <memgraph/mgp.hpp>
#include <memgraph/mg_exceptions.hpp>

const char *kProcedureGet = "get";
const char *kParameterStart = "start";
const char *kParameterSteps = "steps";
const char *kReturnStep = "step";
const char *kReturnNode = "node";
 
void RandomWalk(mgp_list *args, mgp_graph *memgraph_graph, mgp_result *result, mgp_memory *memory) {
  mgp::MemoryDispatcherGuard guard(memory);
 
  const auto arguments = mgp::List(args);
  const auto record_factory = mgp::RecordFactory(result);
 
  const auto start = arguments[0].ValueNode();
  const auto n_steps = arguments[1].ValueInt();
 
  srand(time(NULL));
 
  auto current_nodes = mgp::List();
  current_nodes.AppendExtend(mgp::Value(start));
 
  std::int64_t step = 0;
  while (step <= n_steps) {
    auto current_node = current_nodes[current_nodes.Size() - 1].ValueNode();
 
    auto neighbours = mgp::List();
    for (const auto relationship : current_node.OutRelationships()) {
      neighbours.AppendExtend(mgp::Value(relationship));
    }
 
    if (neighbours.Size() == 0) {
      break;
    }
 
    const auto next_node = neighbours[rand() % neighbours.Size()].ValueRelationship().To();
 
    current_nodes.AppendExtend(mgp::Value(next_node));
    step++;
  }
 
  for (std::int64_t i = 0; i < current_nodes.Size(); i++) {
    auto record = record_factory.NewRecord();
    record.Insert(kReturnStep, i);
    record.Insert(kReturnNode, current_nodes[i].ValueNode());
  }
}

extern "C" int mgp_init_module(struct mgp_module *module, struct mgp_memory *memory) {
  mgp::MemoryDispatcherGuard guard(memory);
 
  std::int64_t default_steps = 10;
  try {
    mgp::AddProcedure(RandomWalk, 
                      kProcedureGet, 
                      mgp::ProcedureType::Read,
                      {
                        mgp::Parameter(kParameterStart, mgp::Type::Node),
                        mgp::Parameter(kParameterSteps, mgp::Type::Int, default_steps)
                      },
                      {
                        mgp::Return(kReturnStep, mgp::Type::Int),
                        mgp::Return(kReturnNode, mgp::Type::Node)
                      }, 
                      module,
                      memory);
  } catch (const std::exception &e) {
    return 1;
  }
  return 0;
}

extern "C" int mgp_shutdown_module() { return 0; }

```

We are going to go back and explain the code in detail, but for now, we are going to compile the code.

Keep in mind that you can use any other text editor, at this point it would be recommended to use the one you are most familiar with, connect to the docker contaier via that IDE and create the file there. 
Then you can customise the enviroment to suite your development needs. 


### Compile the query module

First create a `CMakeLists.txt` file in the same directory as your `hello_query_module.cpp` file. You can do this by running the following command:

```bash
vim CMakeLists.txt
```

In the file you can copy the following code:

```cmake
cmake_minimum_required(VERSION 3.10.0)
project(hello_query_module)
set(CMAKE_CXX_STANDARD 20)

add_library(_hello_query_module SHARED hello_query_module.cpp)
```

Create a build direcory and run the cmake command:

```bash
mkdir build
cd build
```

Run the cmake and make: 

```bash
cmake DMAKE_BUILD_TYPE=Release ..
make
```

### Move and load the query module 

After the compilation is done, you can move the query module to the Memgraph query modules directory. You can do this by running the following command:

```bash
mv lib_hello_query_module.so /usr/lib/memgraph/query_modules/lib_hello_query_module.so
```

### Load the query module in Memgraph 

By running mgconsole that is included with every Memgraph image, you can load the query module. You can do this by running the following command:

```bash
mgconsole
```

Once inside the mgconsole, you can load the query module by running the following command:

```bash
CALL mg.load_all();
```

Check that the query module is loaded by running the following command:

```bash
CALL mg.procedures() YIELD *;
```


### Test the query module

Now that we have loaded the query module, we can test it. You can do this by running the following command:

```cypher
CREATE (a:NodeA)-[:Relationship]->(b:NodeB);
```
Call the query module: 

```cypher
MATCH (a:NodeA)
WITH a
CALL lib_hello_query_module.get(a, 1) YIELD node, step
RETURN *;
```

### Next steps 

TODO: Consider a git repository at some point. 
Once your basic query module is working you hava a chance to introduce yourself to the C++ API and start developing your own query modules.

</Steps>

## Query module arhitecture 

Query module allows you to extend the functionality of Memgraph by writing your own custom procedures and functions in C++. Inside the query modules file you can define multiple procedures and functions for different purposes: 

1. **Read or write procedures** 
2. **Magic functions**
3. **Batched procedures** 

Each of this have a specific purpose and are used in different situations, but they share the same arhitecture during the definition of the query module. 

The basic parts of every query module are as follows:

```cpp
#include <mgp.hpp>

// (Query procedure & magic function callbacks)

extern "C" int mgp_init_module(struct mgp_module *module, struct mgp_memory *memory) {
  // Register your procedures & functions here
}

extern "C" int mgp_shutdown_module() {
  // If you need to release any resources at shutdown, do it here
  return 0;
}

```

* The `mgp.hpp` file contains all declarations of the C++ API for implementing
query module procedures and functions. It should be located in the /usr/include/memgraph directory, and it is included with every Memgraph docker image.
* To make your query procedures and functions available, they need to be
registered in `mgp_init_module`. 
* Finally, you may use `mgp_shutdown_module` to reset any global states or release
global resources at shutdown.


### Registering procedures and functions as Query modules 

All query procedures and functions need to be registered in `mgp_init_module`. The way the registration is done depends on the type of the procedure or function.

Here is an example of registering a **read procedure**:

```cpp
extern "C" int mgp_init_module(struct mgp_module *module, struct mgp_memory *memory) {
  try {
    mgp::MemoryDispatcherGuard guard(memory);

    AddProcedure(RandomWalk, "get", mgp::ProcedureType::Read,
                 {mgp::Parameter("start", mgp::Type::Node), mgp::Parameter("length", mgp::Type::Int)},
                 {mgp::Return("random_walk", mgp::Type::Path)}, module, memory);
  } catch (const std::exception &e) {
    return 1;
  }
  return 0;
}
```

Here the procedure’s signature is defined and added it as a readable
procedure `ProcedureType::Read`, named `get`.
The procedure will takes two named parameters (`start` and `length`): the starting node and random walk length,
and it will yields the computed random walk as a `Path` (sequence of nodes connected
by relationships) in the `random_walk` result field.

When the procedure is called, its arguments (& the graph) will be passed to the
`RandomWalk` callback function.

Form the perspective of a Cypher query, you would call this procedure as follows:

```cypher
MATCH (a:NodeA)
WITH a
CALL query_module_name.get(a, 10) YIELD random_walk
RETURN random_walk;
```

In this case `query_module_name` is the name of the query module (compiled .so file) that contains the procedure. 


From perspective of writing an exact RandomWalk procedure, callbacks share the same signature, as laid out below.
Parameter by parameter, the callback receives the procedure **arguments** `args`,
**graph context** `memgraph_graph`, **result stream** (`result`), and **memory** access.

```cpp
void RandomWalk(mgp_list *args, mgp_graph *memgraph_graph, mgp_result *result, mgp_memory *memory) {
  try {
    mgp::MemoryDispatcherGuard guard(memory);
    const auto arguments = mgp::List(args);
    const auto record_factory = mgp::RecordFactory(result);
 
    const auto start_node = args[0].ValueNode();
    const auto length = args[1].ValueInt();
 
    auto random_walk = mgp::Path(start_node);
 
    // (Random walk algorithm logic)
 
    auto record = record_factory.NewRecord();
    record.Insert("random_walk", random_walk);
 
  } catch (const std::exception &e) {
    mgp::result_set_error_msg(result, e.what());
    return;
  }
}
```

Registrating the the write procedure is the same. Aldo, write procedures differ from read procedures in their graph context being mutable.

With them, you may create or delete nodes and relationships, modify their properties, and add or remove node labels.

They use the same interface as readable procedures; the only difference is that the appropriate procedure type parameter is passed to AddProcedure. 
The below code registers and implements a writeable procedure `add_x_nodes`, which adds a user-specified number of nodes to the graph: 

Here is the full example of registering a **write procedure**:

```cpp
extern "C" int mgp_init_module(struct mgp_module *module, struct mgp_memory *memory) {
  try {
    mgp::MemoryDispatcherGuard guard(memory);
 
    mgp::AddProcedure(AddXNodes, "add_x_nodes", mgp::ProcedureType::Write, {mgp::Parameter("number", mgp::Type::Int)},
                      {}, module, memory);
  } catch (const std::exception &e) {
    return 1;
  }
  return 0;
}
``` 

Here is the implementation of the callback function `AddXNodes`:

```cpp
void AddXNodes(mgp_list *args, mgp_graph *memgraph_graph, mgp_result *result, mgp_memory *memory) {
  mgp::MemoryDispatcherGuard guard(memory);
  const auto arguments = mgp::List(args);
  auto graph = mgp::Graph(memgraph_graph);
 
  for (int i = 0; i < arguments[0].ValueInt(); i++) {
    graph.CreateNode();
  }
}
```

#### Registering Magic function 

Magic functions are a Memgraph feature that lets the user write and call custom
Cypher functions. Unlike procedures, functions are simple operations that can’t
modify the graph; they return a single value and can be used in any expression
or predicate.

Let’s examine an example function that multiplies the numbers passed to it. The
registration is done by `AddFunction` in the same way as with query procedures,
the difference being the absence of a "function type" argument (functions don’t
modify the graph).

```cpp
extern "C" int mgp_init_module(struct mgp_module *module, struct mgp_memory *memory) {
  try {
    mgp::MemoryDispatcherGuard guard(memory);

    mgp::AddFunction(Multiply, "multiply",
                     {mgp::Parameter("int", mgp::Type::Int), mgp::Parameter("int", mgp::Type::Int)}, module, memory);
  } catch (const std::exception &e) {
    return 1;
  }
  return 0;
}
```

There are two key differences in the function signature:
* the lack of a `mgp_graph *` parameter (the graph is immutable in functions)
* different result type (functions return single values, while procedures write
result records to the result stream)

The difference in result type means that, to work with function results, we use
a different C++ API class: `Result`. Our function is implemented as follows:

```cpp
void Multiply(mgp_list *args, mgp_func_context *ctx, mgp_func_result *res, mgp_memory *memory) {
  mgp::MemoryDispatcherGuard guard(memory);
  const auto arguments = mgp::List(args);
  auto result = mgp::Result(res);

  auto first = arguments[0].ValueInt();
  auto second = arguments[1].ValueInt();

  result.SetValue(first * second);
}
```


#### Registering Batched procedures

Batched readable and writeable procedures in C++ are pretty similar to batched procedures in C. The way procedures work is the same as in C API, the only difference is procedure registration.

```cpp

void BatchCSVFile(mgp_list *args, mgp_graph *memgraph_graph, mgp_result *result, mgp_memory *memory) {
  ...
}

void InitBatchCsvFile(mgp_list *args, mgp_graph *memgraph_graph, mgp_result *result, mgp_memory *memory) {
  ...
}

void CleanupBatchCsvFile(mgp_list *args, mgp_graph *memgraph_graph, mgp_result *result, mgp_memory *memory) {
  ...
}


extern "C" int mgp_init_module(struct mgp_module *module, struct mgp_memory *memory) {
  try {
    mgp::MemoryDispatcherGuard guard(memory);

    AddBatchProcedure(BatchCSVFile, InitBatchCsvFile, CleanupBatchCsvFile,
                 "read_csv", mgp::ProcedureType::Read,
                 {mgp::Parameter("file_name", mgp::Type::String)},
                 {mgp::Return("row", mgp::Type::Map)}, module, memory);
  } catch (const std::exception &e) {
    return 1;
  }
  return 0;
}
```

## Examples of query modules API usage 

### Read procedure example


void GetNodesFromMemgraph(mgp_list *args, mgp_graph *memgraph_graph, mgp_result *result, mgp_memory *memory){
    const mgp::RecordFactory record_factory = mgp::RecordFactory(result);
    const mgp::List arguments = mgp::List(args);
    const mgp::Graph graph(memgraph_graph);
  
  try {
    mgp::Nodes::Iterator it = graph.Nodes().begin();
    while (it != graph.Nodes().end()) {
      auto record = record_factory.NewRecord();
      mgp::Node node = *it;
      record.Insert(kReturnNodes, std::move(node));
      ++it;
    }
  } catch (const std::exception &e) {
    mgp_error err = mgp_log(mgp_log_level::MGP_LOG_LEVEL_ERROR, "Issue with running the procedure!");      
    record_factory.SetErrorMessage(e.what());
    return;
  }
}
TODO: Node, Edge, Path and property access and return


```cpp

### Write procedure example 

TODO: Create Node, Edge, Path and propery write example 


### Types supported in QM 






## Terminate procedure execution

Just as the execution of a Cypher query can be terminated with [`TERMINATE
TRANSACTIONS "id";`](/fundamentals/transactions) query,
the execution of the procedure can as well, if it takes too long to yield a
response or gets stuck in an infinite loop due to unpredicted input data.

Transaction ID is visible upon calling the SHOW TRANSACTIONS; query.

In order to be able to terminate the procedure, it has to contain function
`graph.CheckMustAbort();` which precedes crucial parts of the code, such as
`while` and `until` loops, or similar points where the procedure might become
costly.

Consider the following example:

```cpp
#include <cstdint>
#include <unordered_map>
#include <unordered_set>
#include <algorithm>
#include <mgp.hpp>
#include <mg_exceptions.hpp>

// Methods
constexpr char const *get = "get";
// Return object names
char const *return_field = "return";


void Test(mgp_list *args, mgp_graph *memgraph_graph, mgp_result *result, mgp_memory *memory) {
    mgp::MemoryDispatcherGuard guard(memory);
    const auto record_factory = mgp::RecordFactory(result);
    auto graph = mgp::Graph(memgraph_graph);
    int64_t id_ = 1;
    try {
        while (true) {
            graph.CheckMustAbort();
            ++id_;
        }
    } catch (const mgp::MustAbortException &e) {
        std::cout << e.what() << std::endl;
        auto new_record = record_factory.NewRecord();
        new_record.Insert(return_field, id_);
    }
}


extern "C" int mgp_init_module(struct mgp_module *module, struct mgp_memory *memory) {
    try {
        mgp::MemoryDispatcherGuard guard(memory);
        mgp::AddProcedure(Test, get, mgp::ProcedureType::Read, {}, {mgp::Return(return_field, mgp::Type::Int)}, module, memory);
    } catch(const std::exception &e) {
        return 1;
    }
    return 0;
}

extern "C" int mgp_shutdown_module() { return 0; }
```


##Callouts 


<Callout type="error">

Any exceptions thrown should never leave the scope of your module. You may have
a top-level exception handler that returns the error value and potentially logs
any error messages.
Exceptions that cross the module boundary may cause unexpected issues!

</Callout>



<Callout type="info">

The API needs memory access for registration; you may grant it with
`mgp::MemoryDispatcherGuard guard(memory)` or `mgp::memory = memory`.

As any exceptions should never leave the scope of the module, the procedure was
registered inside a try-catch block.

</Callout>

<Callout type="error">

As `mgp::memory` is a global object, that means all of the procedures and
functions in a single shared library will refer to the same `mgp::memory`
object. As a result, calling such callables simultaneously from multiple threads
will lead to incorrect memory usage. This also includes the case when the same
callable is called from different user sessions. This is a constraint when using
`mgp::memory` so the use of the thread-safe `MemoryDispatcherGuard guard(memory)`
is advised instead.

</Callout>



Callbacks for query procedures all share the same signature, as laid out below.
Parameter by parameter, the callback receives the procedure arguments (`args`),
graph context (`memgraph_graph`), result stream (`result`), and memory access.

<Callout>

In place of working with the raw `mgp_` type arguments, use the C++ API classes
that provide familiar standard library-like interfaces and do away with needing
manual memory management.

</Callout>