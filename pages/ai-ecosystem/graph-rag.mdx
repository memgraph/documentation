---
title: GraphRAG
description: Learn how Memgraph fits into the architecture of your RAG system.
---
import { Callout, Steps } from 'nextra/components'
import {CommunityLinks} from '/components/social-card/CommunityLinks'


# GraphRAG with Memgraph

## Introduction 

Large Language Models (LLMs) are impressive, but their knowledge is limited to
what they were trained on. By building a Retrieval-Augmented Generation (RAG)
system, you can expand their knowledge with your own data, enabling LLMs to
provide more accurate, personalized responses tailored to your specific domain.

**GraphRAG** takes RAG a step further by combining the strengths of knowledge
graphs with LLMs, creating a system that leverages structured relationships for
reasoning, insights, and efficient retrieval.

**[IMAGE]**

## Knowledge graphs and RAG

Knowledge graphs provide a structured representation of entities and their
relationships, enabling more intelligent data retrieval and reasoning compared
to flat, vector-based systems. Here’s why they’re game-changing for RAG:

- **Relational context** - Graphs encode semantic relationships, offering richer
  insights than traditional data structures.
- **Improved retrieval accuracy** - Graph-specific retrieval techniques like
  community detection and impact analysis provide precise, relevant results.
- **Multi-hop reasoning** - Traverse connected data neighborhoods to uncover
  complex relationships.
- **Efficient information navigation** - Analyze focused subgraphs instead of
  entire datasets.
- **Dynamically Evolving Knowledge** - Real-time graph updates ensure your
  knowledge graph stays current and actionable.

{<h3 className="custom-header">Read more</h3>}

- [How Memgraph Powers Real-Time Retrieval for LLMs](https://memgraph.com/white-paper/knowledge-graphs)


## Memgraph's role in GraphRAG

Memgraph is a high-performance graph database designed to handle the demands of
a GraphRAG system. It combines in-memory performance with features tailored for
AI and real-time applications.

![graphrag-memgraph](/pages/ai-ecosystem/graphrag-memgraph.png)

GraphRAG enables developers to:

- **Structure and model data.** Organize entities and relationships into a
   graph that supports both reasoning and retrieval.
- **Retrieve relevant information.** Use graph-based strategies to extract data
   for LLM queries.
- **Enable real-time performance.** Dynamically update knowledge graphs in
   production to reflect new information.
- **Enhance AI applications.** Provide LLMs with context-rich, precise data for
   better answers and recommendations.
  

A GraphRAG application running in production needs to balance scalability,
performance, and adaptability. Memgraph’s in-memory graph database provides:

- **Real-time performance.** Handle dynamic queries and updates with minimal
  latency.
- **Scalability.** Manage large datasets and complex queries without
  bottlenecks.
- **Durability.** Ensure data persistence for backup, recovery, and long-term
  analysis.


## Key features for GraphRAG

Memgraph equips you with a powerful set of tools and algorithms that make
building a GraphRAG efficient and scalable. Here’s how each feature plays a role
in enhancing your Retrieval-Augmented Generation workflows:

1. [Vector search](/querying/vector-search): A
      pivotal first step for extracting relevant information during pivot
      search. Vector search allows you to perform semantic searches, matching
      context or meaning rather than exact terms.
2. [Deep-path
   traversals](/advanced-algorithms/deep-path-traversal):
      Enables rapid navigation through complex relationships in your graph,
      supporting multi-hop queries and reasoning across interconnected data.
3. [Leiden community
   detection](/advanced-algorithms/available-algorithms/leiden_community_detection):
      A faster, more accurate algorithm than Louvain, Leiden ensures
      well-connected communities, making it ideal for relevance expansion in
      retrieval processes.
4. [Louvain](/advanced-algorithms/available-algorithms/community_detection)
   and [dynamic community
   detection](/advanced-algorithms/available-algorithms/community_detection_online):
      Louvain is a foundational clustering algorithm for discovering
      communities, while dynamic community detection adapts in real time,
      accommodating graph updates without compromising cluster integrity.
5. [PageRank](/advanced-algorithms/available-algorithms/pagerank)
   and [dynamic
   PageRank](/advanced-algorithms/available-algorithms/pagerank_online):
      PageRank ranks nodes based on their influence or importance. Its
      dynamic counterpart adjusts these rankings as new data is ingested,
      ensuring retrieval results remain relevant.
6. [Text search](/querying/text-search):
      Facilitates keyword-based searches, allowing you to locate specific
      entities or relationships within your graph quickly. This complements
      vector search for hybrid retrieval strategies.
7. [Geospatial
      search](/fundamentals/data-types#point):
      Geospatial search enables you to integrate and retrieve location-based
      insights, enhancing the relevance and precision of responses.
8. [Run-time schema
   tracking](/querying/schema#run-time-schema-tracking):
      Tracks schema changes as they happen, enabling seamless updates and
      adaptations in your graph structure without manual intervention. This is
      especially useful if you're including schema into the LLM context.
9. [Real-time data ingestion](/data-streams) - Memgraph supports seamless
integration with streaming platforms like Kafka, Redpanda, and Pulsar, allowing
you to continuously grow and update your knowledge graph. Combine this
with [Memgraph MAGE](/advanced-algorithms) or [custom
procedures](/custom-query-modules) to dynamically query and analyze incoming
data.

![graphrag](/pages/ai-ecosystem/graphrag.png) 

<h3 className="custom-header">Read more</h3>

- [Simplify Data Retrieval with Memgraph’s Vector Search](https://memgraph.com/blog/simplify-data-retrieval-memgraph-vector-search)

## Building GraphRAG with Memgraph

To create a GraphRAG application, start with:

<Steps>

{<h3 className="custom-header">Structuring your data</h3>} 

Follow our [data modeling](/data-modeling) docs to build a graph representation of your domain.

{<h3 className="custom-header">Ingesting data</h3>} 
Follow our [import best practices](/data-migration/best-practices) to populate your graph. 

{<h3 className="custom-header">Use graph features</h3>}
Depending on your specific use case, combine and use different [algorithms](/advanced-algorithms) like deep-path traversals,
community detection, PageRank, and more.

</Steps>

<Callout>
Building GraphRAG takes expertise, iteration, and a deep understanding of your
data and goals. GraphRAG is about managing precisely the graphed context passed
to LLMs. 

Because GraphRAG solutions are highly case-specific, there’s no universal recipe
for success. Instead, we provide
[examples](/ai-ecosystem/graph-rag/examples-and-demos) to inspire and guide you:

- See different approaches.
- Learn from what we’ve done.
- Explore what others are building with Memgraph.
</Callout>

<CommunityLinks/>