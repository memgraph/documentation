---
title: cycles
description: Discover Memgraph's cycle analysis capabilities for graphs. Enhance your understanding of identifying and analyzing cycles within graphs, and much more. 
---

import { Steps } from 'nextra/components'
import { Callout } from 'nextra/components'

# cycles



In graph theory, a cycle represents a path within the graph where only the starting and ending nodes are equal. Furthermore, cycles can be double-connected links between neighboring nodes or self-loops. The cycles detection algorithm implemented within MAGE works on an undirected graph and has **no guarantee** of node order in the output. The implemented algorithm (Gibb) is described in the 1982 MIT report called "[Algorithmic approaches to circuit enumeration problems and applications](http://hdl.handle.net/1721.1/68106)" [^1]. The problem is not solvable in polynomial time. It is based on finding all subsets of fundamental cycles which takes about O(2^(|E|-|V|+1)) time where E represents a set of edges and V represents a set of vertices of the given graph.

[^1] [Algorithmic approaches to circuit enumeration problems and applications](http://hdl.handle.net/1721.1/68106), Boon Chai Lee

[![docs-source](https://img.shields.io/badge/source-cycles-FB6E00?logo=github&style=for-the-badge)](https://github.com/memgraph/mage/blob/main/cpp/cycles_module/cycles_module.cpp)

| Trait               | Value                                                 |
| ------------------- | ----------------------------------------------------- |
| **Module type**     | algorithm  |
| **Implementation**  | C++        |
| **Graph direction** | undirected |
| **Edge weights**    | unweighted |
| **Parallelism**     | sequential |

## Procedures

<Callout type="info">
You can execute this algorithm on [graph projections, subgraphs or portions of the graph](/advanced-algorithms/run-algorithms#run-procedures-on-subgraph).
</Callout>

### `get()`

{<h4> Output: </h4>}

* `cycle_id` ➡ Incremental cycle ID of a certain vertex. There is no guarantee on how nodes are going to be ordered within cycle. The cycle can be represented with a minimum of one ID, where it stands for self-loop.
* `node` ➡ Vertex object with all properties which is going to be related to the cycle ID it belongs to.

{<h4> Usage: </h4>}
```cypher
CALL cycles.get()
YIELD cycle_id, node;
```

## Example

<Steps>
### Input graph
![](/pages/advanced-algorithms/available-algorithms/cycles/cycles-1.png)

### Cypher load commands
```cypher
MERGE (a:Node {id: 0}) MERGE (b:Node {id: 1}) CREATE (a)-[:RELATION]->(b);
MERGE (a:Node {id: 0}) MERGE (b:Node {id: 2}) CREATE (a)-[:RELATION]->(b);
MERGE (a:Node {id: 1}) MERGE (b:Node {id: 2}) CREATE (a)-[:RELATION]->(b);
MERGE (a:Node {id: 2}) MERGE (b:Node {id: 3}) CREATE (a)-[:RELATION]->(b);
MERGE (a:Node {id: 2}) MERGE (b:Node {id: 4}) CREATE (a)-[:RELATION]->(b);
MERGE (a:Node {id: 3}) MERGE (b:Node {id: 4}) CREATE (a)-[:RELATION]->(b);
```

### Running command
```cypher
CALL cycles.get()
YIELD cycle_id, node
RETURN cycle_id, node;
```

### Results
```plaintext
+-----------------+-----------------+
| cycle_id        | node            |
+-----------------+-----------------+
| 0               | (:Node {id: 2}) |
| 0               | (:Node {id: 0}) |
| 0               | (:Node {id: 1}) |
| 1               | (:Node {id: 4}) |
| 1               | (:Node {id: 2}) |
| 1               | (:Node {id: 3}) |
+-----------------+-----------------+
```
</Steps>


