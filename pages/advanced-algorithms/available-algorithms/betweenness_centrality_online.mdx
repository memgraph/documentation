---
title: betweenness_centrality_online
description: Access Memgraph's advanced betweenness centrality computation functions. With detailed tutorials and comprehensive documentation, optimize your graph analysis queries. 
---

import { Steps } from 'nextra/components'
import { Callout } from 'nextra/components'
import { Card, Cards } from 'nextra/components'

# betweenness_centrality_online

In network studies, centrality analysis illuminates the significance of nodes,
with betweenness centrality being one of the most important metrics. It
determines the importance of a node based on how frequently it lies on the
shortest paths between other nodes, signifying its influence on information flow
within the network. Such nodes, possessing high betweenness, often act as
gatekeepers in controlling the transmission of information.

While the concept of betweenness centrality revolves around shortest paths,
defined by the fewest relationships or minimal cumulative relationship weight in
weighted graphs, the calculation methodologies can vary. One notable method is
described in the paper ["A Faster Algorithm for Betweenness
Centrality"](http://www.uvm.edu/pdodds/research/papers/others/2001/brandes2001a.pdf)(Jamour
et al., 2017). Additionally, the
[iCentral](https://repository.kaust.edu.sa/bitstream/handle/10754/625935/08070346.pdf)
algorithm by Jamour, Skiadopoulos, and Kalnis offers a dynamic solution tailored
for graph streaming platforms like Memgraph. By pinpointing nodes with
potentially altered centrality scores and incrementally updating them, iCentral
optimizes computation. This efficiency translates to a time complexity of
O(m′n′) and space complexity of O(m + n), making it apt for medium-scale graphs.

In essence, centrality analysis and tools like iCentral are instrumental in
extracting value from complex networks, ensuring data remains current and
reflective of real-time changes.

<Cards>
  <Card
    title="Source code"
    href="https://github.com/memgraph/mage/blob/main/cpp/betweenness_centrality_module/betweenness_centrality_online_module.cpp"
  />
</Cards>

| Trait               | Value                                                 |
| ------------------- | ------------- |
| **Module type**     | algorithm     |
| **Implementation**  | C++           |
| **Graph direction** | undirected    |
| **Edge weights**    | unweighted    |
| **Parallelism**     | parallel      |

## Procedures

<Callout type="info">
You can execute this algorithm on [graph projections, subgraphs or portions of the graph](/advanced-algorithms/run-algorithms#run-procedures-on-subgraph).
</Callout>

### `set()`

{<h4> Input: </h4>} 

- `normalize: boolean (default=True)` ➡ If `True`, the betweenness values are normalized by
  `2/((n-1)(n-2))`, where `n` is the number of nodes in the graph.
- `threads: integer (default=Nº of concurrent threads supported by the implementation)` ➡ The
  number of threads used in calculating betweenness centrality.

{<h4> Output: </h4>} 

- `node: Vertex` ➡ Graph vertex.
- `betweenness_centrality: float` ➡ Betweenness centrality score of the above
  vertex.

{<h4> Usage: </h4>} 

```cypher
CALL betweenness_centrality_online.set()
YIELD node, betweenness_centrality;
```

### `get()`

{<h4> Input: </h4>} 

- `normalize: boolean (default=True)` ➡ If `True`, the betweenness values are normalized by
  `2/((n-1)(n-2))`, where `n` is the number of nodes in the graph.

{<h4> Output: </h4>} 

- `node: Vertex` ➡ Graph vertex.
- `betweenness_centrality: float` ➡ Betweenness centrality score of the above
  vertex.

{<h4> Usage: </h4>} 

```cypher
CALL betweenness_centrality_online.get()
YIELD node, betweenness_centrality;
```

### `update()`

{<h4> Input: </h4>} 

- `created_vertices: List[Vertex]` ➡ Vertices created in the latest graph
  update.
- `created_edges: List[Edge]` ➡ Edges created in the latest graph update.
- `updated_vertices: List[Vertex]` ➡ Vertices updated in the latest graph
  update.
- `updated_edges: List[Edge]` ➡ Edges updated in the latest graph update.
- `deleted_vertices: List[Vertex]` ➡ Vertices deleted in the latest graph
  update.
- `deleted_edges: List[Edge]` ➡ Edges deleted in the latest graph update.
- `normalize: boolean (default=True)` ➡ If `True`, the betweenness values are normalized by
  `2/((n-1)(n-2))`, where `n` is the number of nodes in the graph.
- `threads: integer (default=Nº of concurrent threads supported by the implementation)` ➡ The
  number of threads used in updating betweenness centrality.

{<h4> Output: </h4>} 

- `node: Vertex` ➡ Graph vertex.
- `betweenness_centrality: float` ➡ Betweenness centrality score of the above
  vertex.

{<h4> Usage: </h4>} 

As there is a total of four complex obligatory parameters, setting the
parameters by hand might be cumbersome. The recommended use of this method is to
call it within a [trigger](/fundamentals/triggers), making sure
beforehand that all [predefined
variables](/fundamentals/triggers/#predefined-variables) are
available:

```cypher
CREATE TRIGGER sample_trigger BEFORE COMMIT
EXECUTE CALL betweenness_centrality_online.update(createdVertices, createdEdges, deletedVertices, deletedEdges, normalize, threads) YIELD *;
```

Communities calculated by `update()` are accessible by subsequently calling
`get()`:

```cypher
CALL betweenness_centrality_online.get()
YIELD node, betweenness_centrality;
```

## Example

<Steps>

{<h3> Database state </h3>} 

The database contains the following data: 

![](/pages/advanced-algorithms/available-algorithms/betweenness_centrality_online/betweenness-centrality-online-1.png)

{<h3> Create a trigger </h3>} 

The following query sets a trigger which will update the values upon creating new data or deleting existing data: 

```
CREATE TRIGGER update_bc_trigger
BEFORE COMMIT EXECUTE
  CALL betweenness_centrality_online.update(createdVertices, createdEdges, deletedVertices, deletedEdges)
  YIELD *;
```

{<h3> Add new data </h3>} 

New data is added to the database: 

```
MERGE (a: Node {id: 0}) MERGE (b: Node {id: 1}) CREATE (a)-[:RELATION]->(b);
MERGE (a: Node {id: 0}) MERGE (b: Node {id: 2}) CREATE (a)-[:RELATION]->(b);
MERGE (a: Node {id: 1}) MERGE (b: Node {id: 2}) CREATE (a)-[:RELATION]->(b);
MERGE (a: Node {id: 2}) MERGE (b: Node {id: 3}) CREATE (a)-[:RELATION]->(b);
MERGE (a: Node {id: 3}) MERGE (b: Node {id: 4}) CREATE (a)-[:RELATION]->(b);
MERGE (a: Node {id: 3}) MERGE (b: Node {id: 5}) CREATE (a)-[:RELATION]->(b);
MERGE (a: Node {id: 4}) MERGE (b: Node {id: 5}) CREATE (a)-[:RELATION]->(b);
```

As new data is added, the triggered `betweenness_centrality_online.update()` procedure recalculates the values. 

{<h3> Get recalculated values </h3>} 

Return the values using the following query:

```
CALL betweenness_centrality_online.get(True)
YIELD node, betweenness_centrality
RETURN node.id AS node_id, betweenness_centrality
ORDER BY node_id;
```

Results:

```
┌─────────────────────────┬─────────────────────────┐
│ node_id                 │ betweenness_centrality  │
├─────────────────────────┼─────────────────────────┤
│ 0                       │ 0                       │
│ 1                       │ 0                       │
│ 2                       │ 0.6                     │
│ 3                       │ 0.6                     │
│ 4                       │ 0                       │
│ 5                       │ 0                       │
└─────────────────────────┴─────────────────────────┘
```

</Steps>