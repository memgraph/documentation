---
title: bipartite_matching
description: Explore Memgraph's advanced bipartite matching algorithm to enhance your graph analysis capabilities. Get started with our documentation on the potential of advanced computation.
---

import { Steps } from 'nextra/components'
import { Callout } from 'nextra/components'

# bipartite_matching

export const Highlight = ({children, color}) => (
  <span
    style={{
      backgroundColor: color,
      borderRadius: '2px',
      color: '#fff',
      padding: '0.2rem',
    }}>
    {children}
  </span>
);

A bipartite graph is a graph in which we can divide vertices into two independent sets, such that every edge connects vertices between these sets. No connection can be established within the set. Matching in bipartite graphs (bipartite matching) is described as a set of edges that are picked in a way to not share an endpoint. Furthermore, maximum matching is such matching of maximum cardinality of the chosen edge set. The algorithm runs in O(|V|*|E|) time where V represents a set of nodes and E represents a set of edges.

[![docs-source](https://img.shields.io/badge/source-bipartite_matching-FB6E00?logo=github&style=for-the-badge)](https://github.com/memgraph/mage/blob/main/cpp/bipartite_matching_module/bipartite_matching_module.cpp)


| Trait               | Value                                                 |
| ------------------- | ----------------------------------------------------- |
| **Module type**     | <Highlight color="#FB6E00">**algorithm**</Highlight>  |
| **Implementation**  | <Highlight color="#FB6E00">**C++**</Highlight>        |
| **Graph direction** | <Highlight color="#FB6E00">**undirected**</Highlight> |
| **Edge weights**    | <Highlight color="#FB6E00">**unweighted**</Highlight> |
| **Parallelism**     | <Highlight color="#FB6E00">**sequential**</Highlight> |

## Procedures

<Callout type="info">
If you want to execute this algorithm on graph projections, subgraphs or portions of the graph, be sure to check out [how to run a MAGE module on subgraphs](/advanced-algorithms/run-algorithms#run-procedures-on-subgraph).
</Callout>

### `max()`

#### Output:

* `maximum_bipartite_matching` âž¡ Maximum bipartite matching, the cardinality of maximum matching edge subset. If graph is not bipartite, zero(0) is returned value.

#### Usage:
```cypher
CALL bipartite_matching.max()
YIELD maximum_bipartite_matching;
```

## Example

<Steps>
### Input graph
![](/pages/advanced-algorithms/available-algorithms/bipartite_matching/bipartite-matching-1.png)

### Cypher load commands
```cypher
MERGE (a:Node {id: 0}) MERGE (b:Node {id: 3}) CREATE (a)-[:RELATION]->(b);
MERGE (a:Node {id: 0}) MERGE (b:Node {id: 5}) CREATE (a)-[:RELATION]->(b);
MERGE (a:Node {id: 1}) MERGE (b:Node {id: 3}) CREATE (a)-[:RELATION]->(b);
MERGE (a:Node {id: 1}) MERGE (b:Node {id: 4}) CREATE (a)-[:RELATION]->(b);
MERGE (a:Node {id: 2}) MERGE (b:Node {id: 4}) CREATE (a)-[:RELATION]->(b);
```

### Running command
```cypher
CALL bipartite_matching.max()
YIELD maximum_bipartite_matching
RETURN maximum_bipartite_matching;
```

### Results
```plaintext
+----------------------------+
| maximum_bipartite_matching |
+----------------------------+
| 3                          |
+----------------------------+
```
</Steps>
