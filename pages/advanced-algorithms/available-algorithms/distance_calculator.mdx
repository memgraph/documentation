---
title: distance_calculator
description: Optimize your graph analysis with Memgraph's distance calculator. Explore tutorials and comprehensive documentation to learn how to calculate distances and shortest paths between nodes in your graphs.
---

import { Steps } from 'nextra/components'
import { Callout } from 'nextra/components'

# distance_calculator



The distance calculator is a module for calculating distance between two geographic locations. It measures the distance along the surface of the earth. 
Formula takes into consideration the radius of the earth. For this algorithm, it is necessary to define an object that has longitude and latitude properties like this:

```cypher
(location:Location {lat: 44.1194, lng: 15.2314})
```

[![docs-source](https://img.shields.io/badge/source-distance_calculator-FB6E00?logo=github&style=for-the-badge)](https://github.com/memgraph/mage/blob/main/cpp/distance_calculator/distance_calculator.cpp)

| Trait               | Value                                                 |
| ------------------- |-------------------------------------------------------|
| **Module type**     | module     |
| **Implementation**  | C++        |
| **Graph direction** | undirected |
| **Edge weights**    | unweighted |
| **Parallelism**     | sequential |

## Procedures

<Callout type="info">
You can execute this algorithm on [graph projections, subgraphs or portions of the graph](/advanced-algorithms/run-algorithms#run-procedures-on-subgraph).
</Callout>

### `single(start, end, metrics, decimals)`

{<h4> Input: </h4>}

* `start: Vertex` ➡ Starting point to measure distance. Required to have *lng* and *lat* properties.
* `end: Vertex` ➡ Ending point to measure distance. Required to have *lng* and *lat* properties.
* `metrics: string` ➡ Can be either "m" or "km". These stand for meters and kilometers respectively.
* `decimals:int` ➡ Number of decimals on which you want to round up number.

{<h4> Output: </h4>}

* `distance: double` ➡ The final result obtained by calculating distance (in 'm' or 'km') between the 2 points that each have its latitude and longitude properties.

{<h4> Usage: </h4>}
```cypher
MATCH (n:Location), (m:Location)
CALL distance_calculator.single(m, n, 'km')
YIELD distance
RETURN distance;
```

### `multiple(start_points, end_points, metrics, decimals)`

{<h4> Input: </h4>}

* `start_points: List[Vertex]` ➡ Starting points to measure distance collected in a list. Required to have *lng* and *lat* properties. Must be of the same size as *end_points*.
* `end_points: List[Vertex]` ➡ Ending points to measure distance collected in a list. Required to have *lng* and *lat* properties. Must be of the same size as *start_points*.
* `metrics: string` ➡ Can be either "m" or "km". These stand for metres and kilometres respectively.
* `decimals:int` ➡ Number of decimals on which you want to round up number.

{<h4> Output: </h4>}

* `distance: List[double]` ➡ The final result obtained by calculating distance (in meters) between the 2 points who each have its latitude and longitude.

{<h4> Usage: </h4>}
```cypher
MATCH (n), (m)
WITH COLLECT(n) AS location_set1, COLLECT(m) AS location_set2
CALL distance_calculator.multiple(location_set1, location_set2, 'km') YIELD distances
RETURN distances;
```

## Example

<Steps>
### Input graph

![](/pages/advanced-algorithms/available-algorithms/distance_calculator/distance-calculator-1.png)

### Cypher load commands

```
CREATE (location:Location {name: 'Zagreb', lat: 45.8150, lng: 15.9819});
CREATE (location:Location {name: 'Zadar', lat: 44.1194, lng: 15.2314});
```

### Running command

```
MATCH (n {name: 'Zagreb'}), (m {name: 'Zadar'})
CALL distance_calculator.single(n, m, 'km') YIELD distance
RETURN distance;
```

### Results

```
+----------+
| distance |
+----------+
| 197.568  |
+----------+
```
</Steps>

