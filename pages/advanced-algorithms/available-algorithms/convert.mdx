---
title: convert
description: Harness Memgraph's convert module to transform data structures into tree representations efficiently. Visualize the potential with detailed documentation and tutorials.
---

# convert

import { Callout } from 'nextra/components'
import { Cards } from 'nextra/components'
import GitHub from '/components/icons/GitHub'

The convert module is a data transformation module that offers functions
to convert various data structures into different formats, allowing operations
like tree conversion, data type transformation, and structural modifications
for efficient data handling.

Functions in the collection are called inline, while the procedure is called
using the `CALL` subclause. 


<Cards>
  <Cards.Card
    icon={<GitHub />}
    title="Source code"
    href="https://github.com/memgraph/mage/blob/main/cpp/convert_module/convert_module.cpp"
  />
</Cards>

| Trait               | Value                                                 |
| ------------------- | ---------- |
| **Module type**     | util       |
| **Implementation**  | C++        |
| **Graph direction** | directed   |
| **Edge weights**    | weighted   |
| **Parallelism**     | sequential |

## Procedures

### `to_tree()`

Converts the provided value into a tree structure based on the specified configuration.
This procedure is useful for transforming hierarchical data, nested objects, or
graph structures into a standardized tree format.

<Callout type="info">
This procedure is equivalent to **apoc.convert.toTree**.
</Callout>

{<h4 className="custom-header"> Input: </h4>}

- `subgraph: Graph` (**OPTIONAL**) ➡ A specific subgraph, which is an [object of type Graph](/advanced-algorithms/run-algorithms#run-procedures-on-subgraph) returned by the `project()` function, on which the algorithm is run. 
If subgraph is not specified, the algorithm is computed on the entire graph by default.
- `value: Any` ➡ The input value that needs to be converted to a tree structure.
- `config: Map({})` ➡ Configuration options for the tree conversion process.

{<h4 className="custom-header"> Output: </h4>}

- `tree: Any` ➡ The resulting tree structure.

{<h4 className="custom-header"> Usage: </h4>}

Use the following query to convert graph paths to a tree structure:

```cypher
CREATE (a:Student {name: 'Ana'});
CREATE (b:Student {name: 'Bob'});
CREATE (c:Student {name: 'Carol'});
CREATE (d:Student {name: 'Dave'});
CREATE (e:Student {name: 'Eve'});
MATCH (a:Student {name: 'Ana'}), (b:Student {name: 'Bob'}) CREATE (a)-[:FRIEND]->(b);
MATCH (a:Student {name: 'Ana'}), (c:Student {name: 'Carol'}) CREATE (a)-[:FRIEND]->(c);
MATCH (b:Student {name: 'Bob'}), (d:Student {name: 'Dave'}) CREATE (b)-[:COLLEAGUE]->(d);
MATCH (c:Student {name: 'Carol'}), (e:Student {name: 'Eve'}) CREATE (c)-[:FRIEND]->(e);
MATCH (d:Student {name: 'Dave'}), (e:Student {name: 'Eve'}) CREATE (d)-[:FRIEND]->(e);

MATCH p = (a:Student {name: 'Ana'})-[*]->(e:Student {name: 'Eve'})
WITH collect(p) AS paths
CALL convert.to_tree(paths) YIELD tree
RETURN tree;
```

The output shows the tree structure with relationships grouped by type:

```json
{
   "COLLEAGUE": [
      {
         "_id": 345004,
         "_type": "Student",
         "name": "Dave"
      }
   ],
   "FRIEND": [
      {
         "_id": 345002,
         "_type": "Student",
         "name": "Bob"
      },
      {
         "_id": 345005,
         "_type": "Student",
         "name": "Eve"
      },
      {
         "_id": 345003,
         "_type": "Student",
         "name": "Carol"
      }
   ],
   "_id": 345001,
   "_type": "Student",
   "name": "Ana"
}
```
