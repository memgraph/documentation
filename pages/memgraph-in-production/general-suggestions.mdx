---
title: General suggestions
description: General suggestions when working with Memgraph, from testing to production. 
---

import { Callout } from 'nextra/components'

# General Suggestions

This section provides guidance for getting started with Memgraph, regardless of the specific workload you want to test it on. It's ideal for those who are either testing Memgraph for the first time or working with a simple dataset. Once you determine which workload best suits your data and use case, you can refer to the more specific guides in the *Memgraph in Production* series for tailored recommendations.

## What is Covered?

The general suggestions cover the following key areas:

**1. [Hardware Requirements for running Memgraph](#1-hardware-requirements-for-running-memgraph)** <br />
Learn how to select the best machine for Memgraph based on your resources, whether on-prem, in a data center, or via cloud offerings (e.g., AWS, GCP, Azure).

**2. [Hardware Sizing](#2-hardware-sizing)** <br />
Since Memgraph is an in-memory database, estimating RAM requirements is crucial. This section helps you allocate memory based on dataset size and expected workloads.

**3. [Hardware Configuration](#3-hardware-configuration)** <br />
Optimize your host machine configuration for Memgraph to run smoothly, including key parameters for effective operation.

**4. [Networking Configuration](#4-networking-options)** <br />
Learn the best ways to configure networking to enable Memgraph’s interaction with the outside world and ensure smooth communication with external systems or users.

**5. [Deployment Options](#5-deployment-options)** <br />
Understand the tradeoffs between running Memgraph natively on a host machine or in a containerized environment (Docker, K8s) to choose the best deployment method.

**6. [Choosing the Right Memgraph Flag Set](#6-choosing-the-right-memgraph-flag-set)** <br />
Memgraph offers a variety of configuration flags for performance, persistence, and other features. This section guides you on setting the right flags based on your use case.

**7. [Importing Mechanisms](#7-importing-mechanisms)** <br /> 
Discover the best methods for importing your dataset into Memgraph, including Cypher queries, bulk loading, and integrations with other data sources.

**8. [Enterprise Features You Might Require](#8-enterprise-features-you-might-require)**  <br />
Memgraph offers a suite of enterprise-grade features that enhance scalability, security, and manageability.
Key features include role-based access control (RBAC), advanced monitoring tools high availability cluster setups, 
multitenancy, and more. These features ensure that your data is secure, available, and that Memgraph can scale to meet
the demands of enterprise workloads.

**9. [Queries That Best Suit Your Workload](#9-queries-that-best-suit-your-workload)**  <br />
The type of queries you use can significantly affect performance, especially as the dataset grows or the workload 
complexity increases. For general use cases, simple Cypher queries are sufficient, but as your workload 
scales, more advanced query optimization techniques are necessary. Also, a different set of queries is needed based on the use case,
which will be covered in the specific use case sections.

## Bringing Memgraph to Production

## 1. Hardware Requirements for Running Memgraph

To get started with Memgraph, we recommend checking the [system requirements](/getting-started/install-memgraph#system-requirements) listed
in our installation guide. These requirements are sufficient for setting up Memgraph on your own servers.

If you're deploying Memgraph using a cloud provider, visit the [deployment section](/deployment) for guidance on choosing the appropriate
instance type for your specific cloud environment.

## 2. Hardware Sizing

The most critical factor in provisioning a server for Memgraph is **RAM**. Memgraph operates primarily in **in-memory mode**, meaning
the entire dataset is loaded into RAM for optimal performance. Properly sizing your RAM is essential to ensuring your system runs efficiently
and can scale with your workload.

For a deeper dive into how memory usage is calculated, refer to our [Memory Storage Guide](/fundamentals/storage-memory-usage). Below is a
simplified, rule-of-thumb approach to help you estimate your memory needs.

### Memory Components

Memgraph’s memory usage consists of five main parts:

1. **Node Memory**  
   Each node requires approximately **128 bytes**.

2. **Relationship Memory**  
   Each relationship requires approximately **120 bytes**.

3. **Property Storage**  
   Properties are stored in buffered arrays. The memory needed depends on property types and counts.

4. **Indices**  
   Additional overhead is introduced by indexing node labels, edge types, and properties.

5. **Query Execution Memory**  
   Temporary memory required to execute queries. This varies depending on the complexity of queries.

<Callout type="info">
Items 1–4 are referred to as **memory at rest**, while query execution memory is often called **compute memory**.
</Callout>

### RAM Sizing Guidelines

Use the following steps to estimate the RAM required for your workload:

#### Step 1: Estimate Base Graph Storage
For datasets with minimal properties (3–5 small properties), use this formula:
```
128 * N + 120 * M
```
Where:
- `N` = number of nodes
- `M` = number of relationships  
The result gives you the dataset size in **bytes**.

<Callout type="info">
**Don’t know how many nodes or relationships you have?**  
If your data is in a non-graph format (e.g., CSV), estimating the number of nodes and relationships isn’t always straightforward.
For example, one line in a CSV file could represent a node, a relationship, or a mix of both. In some cases, nodes and relationships are
split into separate CSV files.

In such cases, we recommend importing a **sample of the dataset** (around 10%) into Memgraph and using the memory usage for that portion
to extrapolate the estimated requirements for the full dataset. This empirical method provides a more accurate and context-aware estimate
based on how your data is actually represented as a graph.
</Callout>

#### Step 2: Estimate Property Storage
If your dataset includes many or complex properties, refer to the [Memory Storage Guide](/fundamentals/storage-memory-usage) for detailed
calculations. Add this result to the base graph size from Step 1.

#### Step 3: Add Index Overhead
- If you use fewer than 10 indices, this can be skipped.
- If you use many indices (e.g., 50+), add **~20% memory overhead** to the total from Steps 1 and 2.

#### Step 4: Add Query Execution Memory
- For basic querying without graph algorithms: **1.5× multiplier**
- For analytical workloads with algorithms (e.g., PageRank, Community Detection, Betweenness Centrality): **2× multiplier**

### Final Recommendation

Once you've completed these steps:

- Round up your estimate to match available server configurations.
- Example: If your estimate is **96GB**, choose a server with **128GB RAM** for safe headroom.

<Callout type="info">
Still having problems with estimating the size of your instance? Try out our [official storage calculator](https://memgraph.com/storage-calculator), 
or contact us on Discord!
</Callout>

## 3. Hardware Configuration

One of the most important system settings when running Memgraph is configuring the kernel parameter `vm.max_map_count`.
This setting ensures that the system can allocate enough virtual memory areas, which is critical for avoiding memory-related
issues or unexpected crashes during Memgraph operations.

You can find detailed setup instructions and context in our 
[System Configuration documentation](https://memgraph.com/docs/database-management/system-configuration#recommended-values-for-the-vmmax_map_count-parameter).

If you're deploying Memgraph on Kubernetes, our Helm charts include an **init container** that automatically sets `vm.max_map_count`
during startup. However, this container requires **root privileges** to execute. If you're running in a restricted environment
or prefer not to use privileged containers, you’ll need to **manually configure** this parameter on the host machine.

Properly configuring `vm.max_map_count` is a one-time setup but essential for a stable and performant Memgraph deployment.

For system-specific configuration steps and installation guidelines, refer to the [Install Memgraph guide](/getting-started/install-memgraph).

## 4. Networking Configuration

To ensure Memgraph functions properly in your environment, make sure the following ports are open and accessible on your server:

- **7687** – Used for the **Bolt protocol**, which handles all client-to-database communication.
- **3000** – Required if you're using **Memgraph Lab** as a visual interface.
- **7444** – Needed for **streaming logs** from Memgraph to Memgraph Lab.
- **9091** – Used for **system metrics**, an **Enterprise-only** feature. If you're using Prometheus or some other system for tracking system metrics,
this port needs to be enabled.

In addition to enabling these ports, be sure to:

- Review and adjust **firewall settings** to allow traffic on the listed ports.
- On **Red Hat-based systems**, even with the firewall properly configured, you might need to **disable SELinux**, as it can block
Memgraph’s access to system resources.

## 5. Deployment Options

Memgraph can be deployed in two main ways: **natively** as a `.deb` or `.rpm` package on various Linux distributions, or **containerized**
using Docker on any operating system. While native installation can offer up to **10% better performance**, we generally
recommend using the **containerized version**.

The containerized deployment comes pre-packaged with all **MAGE algorithms** and utility tools, eliminating the need for
additional setup. On the other hand, native installations require users to **compile C++ modules** and **manually install Python packages**
to enable the full range of MAGE functionalities—an often complex and error-prone process for most users.

For most use cases, especially during prototyping and production readiness, the containerized image provides the best balance between
performance, simplicity, and feature completeness.

More details and installation instructions can be found in the [Install Memgraph guide](/getting-started/install-memgraph).

## 6. Choosing the right Memgraph flag set
blablah

## 7. Importing Mechanisms
blablah
